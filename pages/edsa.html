<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>ESSA</title>
<style>
  :root{
    --bg:#0e1113; --panel:#161a1d; --ink:#e7e9ec; --muted:#9aa4ad; --accent:#4cc9f0; --accent2:#80ed99; --bad:#ff6b6b;
    --border:#262b30; --overlay:rgba(0,0,0,.55);
  }
  *{box-sizing:border-box}
  html, body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.25 system-ui,Segoe UI,Roboto,Ubuntu,Arial;display:flex;flex-direction:column;min-height:100vh}
  header{display:flex;align-items:center;gap:10px;padding:10px 12px;border-bottom:1px solid var(--border);background:var(--panel);position:sticky;top:0;z-index:5}
  header h1{margin:0;font-size:16px;font-weight:600;letter-spacing:.2px}
  header .spacer{flex:1}
  header input[type=number]{width:80px;background:#0f1113;color:var(--ink);border:1px solid var(--border);padding:6px 8px;border-radius:8px}
  header button, .btn{
    background:#0f1113;border:1px solid var(--border);color:var(--ink);padding:6px 10px;border-radius:8px;cursor:pointer
  }
  header button:hover, .btn:hover{border-color:#353c43}
  .wrap{display:grid;grid-template-columns:minmax(360px, 560px) 1fr;gap:12px;padding:12px;flex:1 1 auto;overflow:hidden}
  @media(max-width:980px){ .wrap{grid-template-columns:1fr} }
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;overflow:hidden;display:flex;flex-direction:column;height:100%}
  .panel h2{margin:0;padding:10px 12px;border-bottom:1px solid var(--border);font-size:13px;text-transform:uppercase;letter-spacing:.8px;color:var(--muted)}
  .panel .body{padding:10px;flex:1 1 auto;overflow:auto;display:flex;flex-direction:column;min-height:0}
  textarea#spec{
    width:100%;height:auto;min-height:220px;resize:vertical;background:#0f1113;color:var(--ink);
    border:1px solid var(--border);border-radius:8px;padding:10px;font-family:ui-monospace,SFMono-Regular,Consolas,monospace;font-size:13px;flex:1 1 auto;min-height:0
  }
  .row{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  select, input[type=text]{background:#0f1113;color:var(--ink);border:1px solid var(--border);padding:6px 8px;border-radius:8px}
  .errors{margin-top:8px;color:var(--bad);white-space:pre-wrap;font-family:ui-monospace,Consolas,monospace}
  .good{color:var(--accent2)}
  .canvasWrap{position:relative;min-height:260px;height:auto;flex:1 1 auto}
  #canvas{position:absolute;inset:0;width:100%;height:100%;background:#0b0d0f;border-radius:10px;cursor:grab}
  canvas.dragging{cursor:grabbing}
  #tooltip{position:absolute;background:#111;border:1px solid #333;padding:6px;border-radius:6px;display:none;pointer-events:none;white-space:pre;color:#eaeef2;font-family:ui-monospace,Consolas,monospace;font-size:12px}
  .results{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
  @media(max-width:1100px){ .results{grid-template-columns:1fr} }
  .results .card{border:1px solid var(--border);border-radius:10px;padding:10px;background:#0f1113}
  .results .card h3{margin:0 0 6px 0;font-size:13px;color:var(--muted);text-transform:uppercase;letter-spacing:.5px}
  .results ul{margin:0;padding:0;list-style:none;max-height:240px;overflow:auto}
  .results li{border-bottom:1px dashed #26303a;padding:4px 0;font-family:ui-monospace,Consolas,monospace}
  .footer{padding:8px 12px;border-top:1px solid var(--border);display:flex;gap:10px;align-items:center;color:var(--muted)}
  .tag{display:inline-flex;align-items:center;gap:6px;padding:3px 8px;border:1px solid var(--border);border-radius:999px;background:#0f1113;color:#cbd5dc;font-size:12px}
  .muted{color:var(--muted)}
  .preset-tip{font-size:12px;color:var(--muted);margin-top:6px}
  .pill{display:inline-block;padding:2px 6px;border:1px solid var(--border);border-radius:999px;font-size:12px;margin-left:6px}

  /* Modal */
  .modalOverlay{position:fixed;inset:0;background:var(--overlay);display:none;align-items:center;justify-content:center;z-index:100}
  .modal{background:#0f1113;border:1px solid var(--border);border-radius:14px;max-width:920px;width:min(92vw,920px);max-height:88vh;overflow:auto;color:var(--ink);box-shadow:0 10px 40px rgba(0,0,0,.5)}
  .modal header{position:sticky;top:0;background:#121518;border-bottom:1px solid var(--border);padding:10px 12px;display:flex;gap:8px;align-items:center}
  .modal header h3{margin:0;font-size:14px;letter-spacing:.3px}
  .modal .content{padding:12px}
  .grid{display:grid;grid-template-columns:1.1fr 1fr;gap:12px}
  @media(max-width:860px){ .grid{grid-template-columns:1fr} }
  fieldset{border:1px solid var(--border);border-radius:10px;padding:10px}
  fieldset legend{padding:0 6px;color:var(--muted);font-size:12px}
  .formRow{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:6px}
  .help{color:var(--muted);font-size:12px}
  .kbd{border:1px solid var(--border);border-radius:6px;padding:0 6px;background:#14181b;font-family:ui-monospace,Consolas,monospace}
  .out{font-family:ui-monospace,Consolas,monospace;background:#0b0f12;border:1px solid var(--border);padding:8px;border-radius:8px}
  .right{display:flex;flex-direction:column;gap:10px}
  .btnRow{display:flex;gap:8px;flex-wrap:wrap}
  .danger{border-color:#8b2b2b !important;color:#ffc3c3 !important}
  .frf-grid{display:flex;flex-direction:column;gap:18px;margin-top:20px}
  .frf-box{background:#101418;border:1px solid var(--border);border-radius:12px;padding:12px}
  .frf-box h4{margin:0 0 8px 0;font-size:13px;color:var(--muted);text-transform:uppercase;letter-spacing:.5px}
  canvas.frfCanvas{width:100%;height:280px;min-height:280px !important;border:1px solid var(--border);border-radius:10px;background:#0b0f12;display:block}
  .modal .summaryTable{width:100%;border-collapse:collapse;margin-top:16px;font-size:12px}
  .modal .summaryTable th,.modal .summaryTable td{border:1px solid var(--border);padding:6px 8px;text-align:left}
  .modal .summaryTable th{background:#14181b;color:var(--muted);text-transform:uppercase;letter-spacing:.6px}
  .dynamicsErrors{color:var(--bad);margin-top:10px;white-space:pre-wrap;font-family:ui-monospace,Consolas,monospace}

  /* Simple badge styles inside library modal */
  .lib-badge{display:inline-block;padding:2px 6px;border:1px solid var(--border);border-radius:999px;font-size:12px;margin-left:6px;color:#cbd5dc;background:#0f1113}
  .lib-list{margin:0;padding-left:16px}
  .lib-list li{margin:6px 0}
  .progressHUD{position:fixed;bottom:20px;right:20px;background:#10161b;border:1px solid var(--border);border-radius:12px;padding:10px 14px;display:flex;align-items:center;gap:10px;box-shadow:0 12px 32px rgba(0,0,0,.45);color:var(--ink);min-width:220px;pointer-events:none;opacity:0;transform:translateY(10px);transition:opacity .18s ease, transform .18s ease;z-index:600;}
  .progressHUD.show{opacity:1;transform:translateY(0);}
  .progressHUD .spinner{width:16px;height:16px;border:2px solid rgba(76,201,240,0.35);border-top-color:var(--accent);border-radius:50%;animation:spin .8s linear infinite;}
  .progressHUD .bar{flex:1;height:6px;background:#161d23;border-radius:999px;overflow:hidden;}
  .progressHUD .bar span{display:block;height:100%;width:0;background:var(--accent2);transition:width .12s ease;}
  .progressHUD .label{font-size:12px;white-space:nowrap;}
  @keyframes spin{to{transform:rotate(360deg);}}
</style>
</head>
<body>
<header>
  <h1>Elasto-Static Simuation & Analysis<span class="pill">(ESSA)</span></h1>
  <div class="spacer"></div>
  <label class="muted">Exag</label>
  <input id="exag" type="number" value="1" step="1" />
  <label class="muted">Zoom</label>
  <input id="zoom" type="number" value="1" step="0.1" />
  <button id="viewFront" class="btn" title="Front (X → camera)">Front View</button>
  <button id="viewSide"  class="btn" title="Side (Y → camera)">Side View</button>
  <button id="viewTop"   class="btn" title="Top (Z → camera)">Top View</button>
  <button id="viewIso"   class="btn" title="Isometric (x←↘, y→↘, z↑)">Isometric</button>
  <button id="toggleBeams" class="btn" title="Show or hide thick beam graphics" aria-pressed="true">Hide Beam Graphics</button>
  <button id="toggleStress" class="btn" title="Show von Mises stress colormap" aria-pressed="false">Show Stress Map</button>
  <button id="btnDynamics" class="btn">Dynamics…</button>
  <button id="btnSolve">Solve</button>
  <button id="btnSave">Save Model Spec</button>
  <button id="btnReset">Reset</button>
  <button id="btnAnimate" class="btn" aria-pressed="false">Animate</button>
  <label class="muted">Hz</label>
  <input id="animateFreq" type="number" value="1" step="0.1" min="0.01" />
</header>

<div class="wrap">
  <div class="panel">
    <h2>Model Spec (3D)</h2>
    <div class="body">

<textarea id="spec" spellcheck="false" placeholder="# 3D compact spec
# Global options (optional)
exag = 20           # displacement exaggeration for view
nu   = 0.30         # Poisson (used if G not provided)

# Optional libraries
materials:
  steel: E=210e9 nu=0.30
  al6061: E=69e9 nu=0.33

xsections:
  tube50x4: shape=tube D=0.05 t=0.004 up=(0,0,1)
  col: shape=rect b=0.08 h=0.16 up=(0,0,1)

nodes:
  1: (0, 0, 0)
  2: (1, 0, 0)

beams:
  # Pick one method per beam (do not mix on a single line):
  # - New: material:<name> xsection:<name>   OR   material:<name> shape=rect b=.. h=.. [up=(..)] [rigid]
  # - Legacy: E=... A=... Iy=... Iz=... J=... [G=...] [up=(..)] [rigid]
  # - Spring: spring k=...   # axial spring (force = k · ΔL)
  # - Rigid: rigid            # rigid link (ties all 6 DOFs)

  1: 1-2  material:steel xsection:col

masses:
  1: mx=100 my=100 mz=100 ix=10 iy=10 iz=10

conditions:
  1: fixed
  2: force Fx=0 Fy=0 Fz=-1000 Mx=0 My=0 Mz=0
"></textarea>

      <div class="row">
        <select id="preset">
          <option value="unittest">Preset: Unit Test</option>
          <option value="cantilever">Preset: Cantilever (Z load)</option>
          <option value="portal">Preset: Portal frame</option>
          <option value="space">Preset: Space frame corner load</option>
          <option value="compliant">Preset: Compliant Mount (sprung support)</option>
          <option value="springdemo">Preset: Axial Spring Example</option>
          <option value="newspec">Preset: Library + Cross-Sections (new spec)</option>
        </select>
        <button class="btn" id="btnPreset">Load Preset</button>
        <button class="btn" id="btnXSec">Cross-Section…</button>
        <button class="btn" id="btnLibs" title="View parsed materials and cross-sections">Libraries…</button>
        <span class="preset-tip">Left-drag: orbit • Shift/🖱️middle/right-drag: pan • Wheel: zoom • <b>Double-click: reset</b></span>
      </div>
      <div class="errors" id="errors"></div>
    </div>
    <div class="footer" id="statusBar">Ready.</div>
  </div>

  <div class="panel">
    <h2>Visualization & Results</h2>
    <div class="body">
      <div class="canvasWrap">
        <canvas id="canvas"></canvas>
        <div id="tooltip"></div>
      </div>

      <div class="results" style="margin-top:10px">
        <div class="card">
          <h3>Displacements (ux, uy, uz, rx, ry, rz)</h3>
          <ul id="dispList"></ul>
        </div>
        <div class="card">
          <h3>Reactions (Fx, Fy, Fz, Mx, My, Mz)</h3>
          <ul id="reactionList"></ul>
        </div>
        <div class="card">
          <h3>Beam End Forces</h3>
          <ul id="beamForceList"></ul>
        </div>
      </div>
    </div>
    <div class="footer">
      <span class="tag">Nodes: <span id="nNodes">0</span></span>
      <span class="tag">Beams: <span id="nBeams">0</span></span>
      <span class="tag">Conditions: <span id="nConds">0</span></span>
      <span class="tag">State: <span id="solveState">unsolved</span></span>
      <span class="tag">Legend: — — undeformed • — deformed • ○ hinge symbol</span>
    </div>
  </div>
</div>

<!-- Save-as Modal -->
<div class="modalOverlay" id="saveOverlay" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="saveTitle">
    <header>
      <h3 id="saveTitle">Save Model Spec</h3>
      <div class="spacer"></div>
      <button id="saveClose" class="btn">Close</button>
    </header>
    <div class="content">
      <div class="formRow" style="grid-template-columns: 1fr auto; align-items:center;">
        <label for="saveFileName">File name</label>
        <input id="saveFileName" type="text" placeholder="my-model.essa" />
      </div>
      <div class="help" style="margin-top:8px">
        Saved to <span class="kbd">~/Documents/ESSA/</span>. Invalid characters will be removed.
      </div>
      <div class="btnRow" style="margin-top:12px">
        <button id="saveConfirm" class="btn">Save</button>
        <button id="saveCancel" class="btn">Cancel</button>
      </div>
      <div id="saveErrors" class="errors" style="margin-top:8px"></div>
    </div>
  </div>
</div>

<!-- Cross-Section Generator Modal -->
<div class="modalOverlay" id="xsecOverlay" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="xsecTitle">
    <header>
      <h3 id="xsecTitle">Generate E, A, Iy, Iz, J from Cross-Section</h3>
      <div class="spacer"></div>
      <button id="xsecClose" class="btn">Close</button>
    </header>
    <div class="content">
      <div class="grid">
        <div>
          <fieldset>
            <legend>Material</legend>
            <div class="formRow">
              <label>Library</label>
              <select id="matLib">
                <option value="steel">Steel (E=210e9, ν=0.30)</option>
                <option value="al">Aluminum 6061-T6 (E=69e9, ν=0.33)</option>
                <option value="ti">Titanium Gr5 (E=114e9, ν=0.34)</option>
                <option value="custom">Custom…</option>
              </select>
              <label>E (Pa)</label>
              <input id="matE" type="text" value="210e9" />
              <label>ν</label>
              <input id="matNu" type="number" step="0.01" value="0.30" />
              <div class="help" style="grid-column:1/-1">G is computed as <span class="kbd">E/(2(1+ν))</span>. Units: SI.</div>
            </div>
          </fieldset>

          <fieldset style="margin-top:10px">
            <legend>Shape & Size (local y = depth, local z = width)</legend>
            <div class="formRow">
              <label>Shape</label>
              <select id="shape">
                <option value="rect">Solid Rectangle (b×h)</option>
                <option value="rectTube">Rectangular Tube (B×H, t)</option>
                <option value="circ">Solid Circle (d)</option>
                <option value="tube">Hollow Circle / Tube (D, t)</option>
                <option value="ibeam">Wide-Flange (I-Beam)</option>
              </select>
              <div></div>

              <!-- Rect -->
              <label class="dim dim-rect">b (width z) [m]</label>
              <input class="dim dim-rect" id="rect_b" type="number" step="0.001" value="0.05" />
              <label class="dim dim-rect">h (height y) [m]</label>
              <input class="dim dim-rect" id="rect_h" type="number" step="0.001" value="0.10" />

              <!-- Rect Tube -->
              <label class="dim dim-rectTube">B (outer width z) [m]</label>
              <input class="dim dim-rectTube" id="rt_B" type="number" step="0.001" value="0.05" />
              <label class="dim dim-rectTube">H (outer height y) [m]</label>
              <input class="dim dim-rectTube" id="rt_H" type="number" step="0.001" value="0.10" />
              <label class="dim dim-rectTube">t (thickness) [m]</label>
              <input class="dim dim-rectTube" id="rt_t" type="number" step="0.0005" value="0.004" />

              <!-- Solid Circle -->
              <label class="dim dim-circ">d (diameter) [m]</label>
              <input class="dim dim-circ" id="c_d" type="number" step="0.001" value="0.05" />

              <!-- Tube -->
              <label class="dim dim-tube">D (outer dia) [m]</label>
              <input class="dim dim-tube" id="t_D" type="number" step="0.001" value="0.05" />
              <label class="dim dim-tube">t (thickness) [m]</label>
              <input class="dim dim-tube" id="t_t" type="number" step="0.0005" value="0.004" />

              <!-- I-beam -->
              <label class="dim dim-ibeam">Bf (flange width z) [m]</label>
              <input class="dim dim-ibeam" id="ib_Bf" type="number" step="0.001" value="0.10" />
              <label class="dim dim-ibeam">H (depth y) [m]</label>
              <input class="dim dim-ibeam" id="ib_H" type="number" step="0.001" value="0.15" />
              <label class="dim dim-ibeam">tf (flange thick) [m]</label>
              <input class="dim dim-ibeam" id="ib_tf" type="number" step="0.0005" value="0.008" />
              <label class="dim dim-ibeam">tw (web thick) [m]</label>
              <input class="dim dim-ibeam" id="ib_tw" type="number" step="0.0005" value="0.006" />
            </div>
            <div class="help" style="margin-top:6px">For torsion on rectangles/I, J uses standard engineering approximations (suitable for most design/visualization purposes). Hollow rectangle J uses thin-wall closed-section formula.</div>
          </fieldset>

          <fieldset style="margin-top:10px">
            <legend>Orientation</legend>
            <div class="formRow">
              <label>up = (y-axis)</label>
              <input id="upVec" type="text" value="0,0,1" />
              <div class="help" style="grid-column:1/-1">This is the local <b>y</b> direction of the cross-section in global XYZ (right-handed).</div>
            </div>
          </fieldset>
        </div>

        <div class="right">
          <fieldset>
            <legend>Computed Properties</legend>
            <div class="formRow">
              <label>A [m²]</label>   <input id="outA" type="text" readonly />
              <label>Iy [m⁴]</label> <input id="outIy" type="text" readonly />
              <label>Iz [m⁴]</label> <input id="outIz" type="text" readonly />
              <label>J [m⁴]</label>  <input id="outJ" type="text" readonly />
              <label>G [Pa]</label>  <input id="outG" type="text" readonly />
            </div>
          </fieldset>

          <fieldset>
            <legend>Spec Snippet</legend>
            <div class="formRow" style="grid-template-columns: auto 1fr; align-items:center; margin-bottom:6px">
              <label for="snMode">Snippet mode</label>
              <select id="snMode">
                <option value="props">Properties (E, A, Iy, Iz, J, G)</option>
                <option value="shape">Shape (shape=.. dims.. up=(..))</option>
              </select>
            </div>
            <div class="out" id="snippet">E=210e9 A=... Iy=... Iz=... J=... G=... up=(0,0,1)</div>
            <div class="btnRow" style="margin-top:8px">
              <button class="btn" id="btnCopy">Copy</button>
              <button class="btn" id="btnInsert">Insert at cursor</button>
            </div>
            <div class="formRow" style="margin-top:8px">
              <label>Apply to beam id</label>
              <select id="beamIdSelect"></select>
              <button class="btn" id="btnApply">Apply</button>
            </div>
            <div class="formRow" style="margin-top:8px">
              <label><input type="checkbox" id="snRigid"/> Add “rigid”</label>
              <div class="help">Check to append the <code>rigid</code> token on insert/apply.</div>
            </div>
            <div class="help">Applying replaces E/A/Iy/Iz/J/G tokens on that beam line (keeps node connection &amp; <code>up=(...)</code> if present).</div>
          </fieldset>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Libraries Modal -->
<div class="modalOverlay" id="libsOverlay" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="libsTitle">
    <header>
      <h3 id="libsTitle">Materials & Cross-Sections</h3>
      <div class="spacer"></div>
      <button id="libsClose" class="btn">Close</button>
    </header>
    <div class="content">
      <div class="help" style="margin-bottom:8px">
        Define in the spec as:
        <div class="out" style="margin-top:6px">
materials:
  steel: E=210e9 nu=0.30
  al6061: E=69e9 nu=0.33

xsections:
  tube50x4: shape=tube D=0.05 t=0.004 up=(0,0,1)
  col: shape=rect b=0.08 h=0.16 up=(0,0,1)

# In beams, pick one method per beam:
# - New: material:steel xsection:tube50x4  (or material:steel shape=rect b=... h=...)
# - Legacy: E=... A=... Iy=... Iz=... J=... [G=...]
        </div>
      </div>
      <div class="grid">
        <div>
          <fieldset>
            <legend>Materials</legend>
            <ul id="libMaterials" class="lib-list"></ul>
          </fieldset>
        </div>
        <div>
          <fieldset>
            <legend>Cross-Sections</legend>
            <ul id="libXSections" class="lib-list"></ul>
          </fieldset>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Dynamics Modal -->
<div class="modalOverlay" id="dynOverlay" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="dynTitle" style="max-width:960px;width:min(94vw,960px);max-height:90vh;">
    <header>
      <h3 id="dynTitle">Modal &amp; Frequency Response</h3>
      <div class="spacer"></div>
      <button id="dynClose" class="btn">Close</button>
    </header>
    <div class="content">
      <div class="formRow" style="grid-template-columns:repeat(3,minmax(140px,1fr));gap:12px">
        <label>Start freq (Hz)<input id="dynFreqStart" type="number" step="0.1" value="1" /></label>
        <label>End freq (Hz)<input id="dynFreqEnd" type="number" step="0.1" value="100" /></label>
        <label>Samples<input id="dynFreqPoints" type="number" min="2" step="1" value="200" /></label>
      </div>
      <div class="formRow" style="grid-template-columns:repeat(2,minmax(160px,1fr));gap:12px;margin-top:10px">
        <label>Drive node<select id="dynDriveNode"></select></label>
        <label>Response node<select id="dynRespNode"></select></label>
      </div>
      <div class="help" style="margin-top:8px">
        Damping uses Rayleigh <span class="kbd">C = 0.001 · K</span>. Responses are computed for all six DOFs at the response node.
      </div>
      <div class="btnRow" style="margin-top:12px">
        <button id="dynCompute" class="btn">Compute FRFs</button>
      </div>
      <label style="display:flex;align-items:center;gap:8px;margin-top:10px;font-size:12px;color:#cbd5dc">
        <input id="dynNormalize" type="checkbox" checked />
        Normalize magnitude (divide by value at start frequency)
      </label>
      <div id="dynErrors" class="dynamicsErrors"></div>
      <div id="dynInfo" class="help" style="margin-top:10px"></div>
      <div id="dynPlots" class="frf-grid">
        <div class="frf-box">
          <h4>Magnitude |H(ω)|</h4>
          <canvas id="frfMagCanvas" class="frfCanvas"></canvas>
        </div>
        <div class="frf-box">
          <h4>Phase ∠H(ω)</h4>
          <canvas id="frfPhaseCanvas" class="frfCanvas"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="progressHUD" class="progressHUD" aria-live="polite" aria-atomic="true">
  <div class="spinner" aria-hidden="true"></div>
  <div class="bar" aria-hidden="true"><span></span></div>
  <span class="label" id="progressHUDLabel">Working…</span>
</div>

<script>
/* =========================
   Core Data / UI refs
   ========================= */
let nodes=[], beams=[], conditions={}, results=null, nuGlobal=null, exagOverride=null;
let materialsLib={}, xsectionsLib={}, nodeMasses={};
let lastAssembly=null, lastFrfResults=null;
const DOF_KEYS=['ux','uy','uz','rx','ry','rz'];
const DOF_LABELS=['UX','UY','UZ','RX','RY','RZ'];
const DOF_UNITS=['m','m','m','rad','rad','rad'];
const DAMPING_BETA=0.001;
const DOF_COLORS=['#4cc9f0','#f72585','#ffba08','#38b000','#7209b7','#fb8b24'];
const MASS_BOX_COLOR='#f9c74f';
const MASS_BOX_ALPHA=0.6;
const chartStates = new Map();
const chartInteractive = new WeakSet();
let animationActive=false;
let animationRequest=null;
let animationStart=0;
let animationTimeSec=0;
let animationMode=null;
const ANIMATION_FREQ_HZ=1;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

const errorsEl = document.getElementById('errors');
const statusBar = document.getElementById('statusBar');
const nNodesEl = document.getElementById('nNodes');
const nBeamsEl = document.getElementById('nBeams');
const nCondsEl = document.getElementById('nConds');
const solveStateEl = document.getElementById('solveState');
const exagEl = document.getElementById('exag');
const zoomEl = document.getElementById('zoom');
const dynOverlay = document.getElementById('dynOverlay');
const dynFreqStartEl = document.getElementById('dynFreqStart');
const dynFreqEndEl = document.getElementById('dynFreqEnd');
const dynFreqPointsEl = document.getElementById('dynFreqPoints');
const dynDriveNodeEl = document.getElementById('dynDriveNode');
const dynRespNodeEl = document.getElementById('dynRespNode');
const dynErrorsEl = document.getElementById('dynErrors');
const dynInfoEl = document.getElementById('dynInfo');
const dynPlotsEl = document.getElementById('dynPlots');
const dynMagCanvas = document.getElementById('frfMagCanvas');
const dynPhaseCanvas = document.getElementById('frfPhaseCanvas');
const dynNormalizeEl = document.getElementById('dynNormalize');
const btnAnimate = document.getElementById('btnAnimate');
const animateFreqEl = document.getElementById('animateFreq');
const progressHUD = document.getElementById('progressHUD');
const progressHUDBar = progressHUD.querySelector('.bar span');
const progressHUDLabel = document.getElementById('progressHUDLabel');
let progressHUDHideTimer=null;
let progressHUDStartTime=null;
let progressHUDBaseLabel='';

const nextFrame = () => new Promise(resolve => requestAnimationFrame(()=>resolve()));

async function notifyProgress(progressCb, fraction, label){
  if(typeof progressCb === 'function'){
    progressCb(fraction, label);
    await nextFrame();
  }
}

function showProgress(label, fraction){
  if(progressHUDHideTimer){ clearTimeout(progressHUDHideTimer); progressHUDHideTimer=null; }
  if(label){
    if(label !== progressHUDBaseLabel){
      progressHUDBaseLabel = label;
      progressHUDStartTime = performance.now();
    }
  }else if(!progressHUDBaseLabel){
    progressHUDBaseLabel = 'Working…';
  }
  if(progressHUDStartTime===null) progressHUDStartTime = performance.now();
  const baseLabel = progressHUDBaseLabel || label || 'Working…';
  progressHUD.classList.add('show');
  if(typeof fraction === 'number' && isFinite(fraction)){
    const clamped = Math.max(0, Math.min(1, fraction));
    progressHUDBar.style.opacity = 1;
    progressHUDBar.style.width = (clamped*100).toFixed(1) + '%';
    const percentText = `${Math.round(clamped*100)}%`;
    let etaText='';
    const elapsed = (performance.now() - progressHUDStartTime)/1000;
    if(clamped>0.01 && clamped<0.999 && elapsed>0.2){
      const remaining = elapsed * ((1-clamped)/Math.max(clamped,1e-3));
      if(remaining>0.3){
        etaText = ` • ≈${formatSeconds(remaining)}`;
      }
    }
    progressHUDLabel.textContent = `${baseLabel} (${percentText}${etaText})`;
  }else{
    progressHUDBar.style.width = '100%';
    progressHUDBar.style.opacity = 0.35;
    progressHUDLabel.textContent = baseLabel;
  }
}
function hideProgress(delay=250){
  if(progressHUDHideTimer){ clearTimeout(progressHUDHideTimer); }
  progressHUDHideTimer = setTimeout(()=>{
    progressHUD.classList.remove('show');
    progressHUDBar.style.width='0%';
    progressHUDBar.style.opacity=1;
    progressHUDHideTimer=null;
    progressHUDStartTime=null;
    progressHUDBaseLabel='';
  }, Math.max(0, delay));
}

function setStatus(msg, ok=true){
  statusBar.innerHTML = ok ? `<span class="good">✔</span> ${msg}` : `<span style="color:#ff6b6b">✖</span> ${msg}`;
}

/* =========================
   Spec Parser (3D) + Rigid + End Releases
   ========================= */
function parseReleaseList(s){
  if(!s) return {};
  const out={rx:false,ry:false,rz:false};
  const parts=s.split(',').map(t=>t.trim().toLowerCase()).filter(Boolean);
  if(parts.includes('all')) return {rx:true,ry:true,rz:true};
  parts.forEach(p=>{ if(p==='rx') out.rx=true; if(p==='ry') out.ry=true; if(p==='rz') out.rz=true; });
  return out;
}
function mergeRel(a,b){ return {rx:!!(a?.rx||b?.rx), ry:!!(a?.ry||b?.ry), rz:!!(a?.rz||b?.rz)}; }

// Compute cross-section properties from shape + dims (SI units)
function computeSectionProps(shape, dims){
  const d = k => Number(dims?.[k]);
  const out = {A:NaN, Iy:NaN, Iz:NaN, J:NaN, dims:{}};
  const pi=Math.PI;
  const isFiniteN = (...vals)=>vals.every(v=>isFinite(v) && v>0);

  if(!shape) return null;
  const sh = String(shape).toLowerCase();
  if(sh==='rect'){
    const b=d('b'), h=d('h');
    if(!isFiniteN(b,h)) return null;
    out.A = b*h;
    out.Iy = b*h*h*h/12;
    out.Iz = h*b*b*b/12;
    let B=b, H=h; if(H>B){ const t=B; B=H; H=t; }
    const r=H/B; out.J = B*H*H*H*(1/3 - 0.21*r*(1 - 0.2*r*r*r*r));
    out.dims={b,h};
    return out;
  } else if(sh==='recttube' || sh==='recttube'){
    const B=d('b'), H=d('h'), t=d('t');
    if(!isFiniteN(B,H,t) || B<=2*t || H<=2*t) return null;
    const Bi=B-2*t, Hi=H-2*t;
    out.A = B*H - Bi*Hi;
    out.Iy = (B*H**3 - Bi*Hi**3)/12;
    out.Iz = (H*B**3 - Hi*Bi**3)/12;
    const Am=(B-t)*(H-t);
    const denom = 2*(B+H-2*t)/t;
    out.J = 4*Am*Am/denom;
    out.dims={B, H, t};
    return out;
  } else if(sh==='circ' || sh==='circle'){
    const D=d('d');
    if(!isFiniteN(D)) return null;
    out.A = pi*D*D/4;
    out.Iy = out.Iz = pi*Math.pow(D,4)/64;
    out.J = pi*Math.pow(D,4)/32;
    out.dims={d:D};
    return out;
  } else if(sh==='tube' || sh==='hollow' || sh==='pipe'){
    const D=d('d'), t=d('t');
    if(!isFiniteN(D,t)) return null;
    const di=D-2*t; if(di<=0) return null;
    out.A = pi*(D*D - di*di)/4;
    out.Iy = out.Iz = pi*(Math.pow(D,4)-Math.pow(di,4))/64;
    out.J = pi*(Math.pow(D,4)-Math.pow(di,4))/32;
    out.dims={D, t};
    return out;
  } else if(sh==='ibeam' || sh==='i-beam' || sh==='wideflange'){
    const Bf=d('bf'), H=d('h'), tf=d('tf'), tw=d('tw');
    if(!isFiniteN(Bf,H,tf,tw)) return null;
    const hw = H - 2*tf; if(hw<=0) return null;
    out.A = 2*(Bf*tf) + (tw*hw);
    const Iy_fl = Bf*tf**3/12;
    const Iy_web = tw*hw**3/12;
    out.Iy = 2*Iy_fl + Iy_web;
    const Iz_fl_c = tf*Bf**3/12;
    const dy = (H/2 - tf/2);
    const Iz_fl = Iz_fl_c + (Bf*tf)*dy*dy;
    const Iz_web = hw*tw**3/12;
    out.Iz = 2*Iz_fl + Iz_web;
    out.J = 2*(Bf*tf**3)/3 + (hw*tw**3)/3;
    out.dims={Bf, H, tf, tw};
    return out;
  }
  return null;
}

function parseSpec(text){
  const lines = text.split(/\r?\n/);
  let section=null;
  let errs=[];
  let tmpNodes=[];
  let tmpBeams=[];
  let tmpConds={};
  let tmpMasses={};
  exagOverride=null;
  nuGlobal=null;
  materialsLib={};
  xsectionsLib={};

  const lineErr=(i,msg)=>errs.push(`Line ${i+1}: ${msg}`);

  const secRe = /^\s*(materials|xsections|nodes|beams|conditions|masses)\s*:\s*$/i;
  const exagRe = /^\s*exag\s*=\s*([-+]?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*$/i;
  const nuRe   = /^\s*nu\s*=\s*([-+]?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*$/i;

  for(let i=0;i<lines.length;i++){
    const raw=lines[i];
    const s = raw.replace(/#.*/,'').trim();
    if(!s) continue;

    let m;
    if((m=s.match(secRe))){ section=m[1].toLowerCase(); continue; }
    if((m=s.match(exagRe))){ const v=parseFloat(m[1]); if(isFinite(v)) exagOverride=v; else lineErr(i,'Invalid exag'); continue; }
    if((m=s.match(nuRe))){ const v=parseFloat(m[1]); if(isFinite(v)) nuGlobal=v; else lineErr(i,'Invalid nu'); continue; }

    if(!section){ lineErr(i,'Expected a section (materials:, xsections:, nodes:, beams:, or conditions:)'); continue; }

    if(section==='materials'){
      // steel: E=210e9 nu=0.30
      const mm=s.match(/^\s*([a-zA-Z0-9_\-]+)\s*:\s*(.*)$/);
      if(!mm){ lineErr(i,'Material:  steel: E=210e9 nu=0.30'); continue; }
      const name=mm[1];
      const tail=mm[2]||'';
      let E=NaN, nu=NaN, sy=NaN;
      tail.split(/\s+/).filter(Boolean).forEach(tok=>{
        const kv=tok.split('='); if(kv.length!==2) return;
        const k=kv[0].toLowerCase(); const v=parseFloat(kv[1]);
        if(k==='e' && isFinite(v)) E=v;
        else if((k==='nu' || k==='v') && isFinite(v)) nu=v;
        else if((k==='sy' || k==='fy' || k==='yield' || k==='sigy' || k==='sigma_y') && isFinite(v)) sy=v;
      });
      if(!isFinite(E) || !isFinite(nu)) { lineErr(i,`Material ${name}: need E and nu`); continue; }
      materialsLib[name]={E, nu, sy: isFinite(sy)? sy : undefined};
    } else if(section==='xsections'){
      // name: shape=rect b=.. h=.. [up=(..)]
      const mm=s.match(/^\s*([a-zA-Z0-9_\-]+)\s*:\s*(.*)$/);
      if(!mm){ lineErr(i,'XSection:  tube50x4: shape=tube D=0.05 t=0.004 up=(0,0,1)'); continue; }
      const name=mm[1];
      const tail=mm[2]||'';
      const def={shape:null, dims:{}, up:null};
      tail.split(/\s+/).filter(Boolean).forEach(tok=>{
        if(/^up=\(/i.test(tok)){
          const m2=tok.match(/^up=\(\s*([^,]+)\s*,\s*([^,]+)\s*,\s*([^)]+)\s*\)$/i);
          if(m2) def.up=[parseFloat(m2[1]),parseFloat(m2[2]),parseFloat(m2[3])];
          return;
        }
        const kv=tok.split('='); if(kv.length!==2) return;
        const k=kv[0].toLowerCase(); const v=parseFloat(kv[1]);
        if(k==='shape'){ def.shape=kv[1].toLowerCase(); }
        else if(isFinite(v)) def.dims[k]=v;
      });
      if(!def.shape){ lineErr(i,`XSection ${name}: need shape=...`); continue; }
    xsectionsLib[name]=def;
    } else if(section==='masses'){
      const mm=s.match(/^\s*(\d+)\s*:\s*(.*)$/);
      if(!mm){ lineErr(i,'Mass:  5: mx=100 my=100 mz=100 ix=10 iy=10 iz=10'); continue; }
      const nid=parseInt(mm[1],10);
      const tail=mm[2]||'';
      const mass={mx:0,my:0,mz:0,ix:0,iy:0,iz:0,width:0,length:0,height:0};
      tail.split(/\s+/).filter(Boolean).forEach(tok=>{
        const kv=tok.split('=');
        if(kv.length!==2) return;
        const key=kv[0].toLowerCase();
        const val=parseFloat(kv[1]);
        if(!isFinite(val)) return;
        if(key==='mx'||key==='my'||key==='mz'||key==='ix'||key==='iy'||key==='iz'){
          mass[key]=val;
        }else if(key==='width'||key==='w'){
          mass.width=val;
        }else if(key==='length'||key==='l'){
          mass.length=val;
        }else if(key==='height'||key==='h'){
          mass.height=val;
        }
      });
      tmpMasses[nid]=mass;
    } else if(section==='nodes'){
      const re=/^\s*(\d+)\s*:\s*\(\s*([-+]?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*,\s*([-+]?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*,\s*([-+]?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*\)\s*$/i;
      const mm=s.match(re);
      if(!mm){ lineErr(i,'Node:  3: (1.0, 2.0, 0.0)'); continue; }
      const id=parseInt(mm[1],10);
      const x=parseFloat(mm[2]), y=parseFloat(mm[3]), z=parseFloat(mm[4]);
      if(tmpNodes.some(n=>n.id===id)) lineErr(i,`Duplicate node id ${id}`); else tmpNodes.push({id,x,y,z});
    } else if(section==='beams'){
      const head=/^\s*(\d+)\s*:\s*(\d+)\s*-\s*(\d+)\s+(.*)$/i;
      const mm=s.match(head);
      if(!mm){ lineErr(i,'Beam:  1: 1-2 E=.. A=.. Iy=.. Iz=.. J=.. [G=..] [up=(..)] [rigid]'); continue; }
      const id=parseInt(mm[1],10), ni=parseInt(mm[2],10), nj=parseInt(mm[3],10);
      const tail=mm[4];
      const parms={}; parms.releaseA={}; parms.releaseB={}; let rigid=false; let methodNew={material:null,xsec:null,shape:null,shapeDims:{},shapeUp:null};
      let type='beam';

      const tokens = tail.split(/\s+/).filter(Boolean);
      tokens.forEach(tok=>{
        const lowerTok = tok.toLowerCase();
        if(lowerTok==='spring'){
          type='spring';
          return;
        } else if(lowerTok.startsWith('spring=')){
          type='spring';
          const val = tok.slice(tok.indexOf('=')+1);
          const kVal = parseFloat(val);
          if(isFinite(kVal)) parms.k = kVal;
          return;
        } else if(lowerTok.startsWith('k=')){
          const kVal = parseFloat(tok.split('=')[1]);
          if(isFinite(kVal)) parms.k = kVal;
          return;
        } else if(lowerTok==='rigid'){
          if(tokens.length===1){
            type='rigidlink';
          }else{
            rigid=true;
          }
          return;
        } else if(/^material:/i.test(tok)){
          const val=tok.replace(/^material:/i,'');
          if(val) methodNew.material=val;
        } else if(/^xsection:/i.test(tok)){
          const val=tok.replace(/^xsection:/i,'');
          if(val) methodNew.xsec=val;
        } else if(/^shape=/i.test(tok)){
          const val=tok.split('=')[1]; if(val) methodNew.shape=val.toLowerCase();
        } else if(/^up=\(/i.test(tok)){
          const m2=tok.match(/^up=\(\s*([^,]+)\s*,\s*([^,]+)\s*,\s*([^)]+)\s*\)$/i);
          if(m2){
            parms.up=[parseFloat(m2[1]),parseFloat(m2[2]),parseFloat(m2[3])];
            methodNew.shapeUp=parms.up;
          }
        } else if(/^rigid(?:=(true|1))?$/i.test(tok)){
          rigid=true;
        // end-release tokens intentionally unsupported for now
        } else {
          const kv=tok.split('=');
          if(kv.length===2){
            const k=kv[0].toLowerCase(); const v=parseFloat(kv[1]);
            if(isFinite(v)){
              parms[k]=v;
              // capture dims when shape= inline method is used
              if(['b','h','bf','tf','tw','d','d','t','b','h','b','h','b','h','rt_b','rt_h'].includes(k)){
                methodNew.shapeDims[k]=v;
              }
              // but better: accept dims generically
              methodNew.shapeDims[k]=v;
            }
          }
        }
      });
      // Determine method
      const hasLegacy = ['e','a','iy','iz','j','g'].some(k=>parms[k]!=null);
      const hasNew = !!(methodNew.material && (methodNew.xsec || methodNew.shape));
      if(type==='rigidlink'){
        if(hasLegacy || hasNew){
          lineErr(i,'Rigid links cannot include material/section properties.');
          continue;
        }
        tmpBeams.push({
          id,
          nodeA:ni,
          nodeB:nj,
          type:'rigidlink'
        });
        continue;
      }
      if(type==='spring'){
        if(hasLegacy || hasNew){
          lineErr(i,'Spring beams cannot mix with material/xsection or E/A/Iy/etc.');
          continue;
        }
        const kspring = (parms.k!=null)? +parms.k : NaN;
        if(!isFinite(kspring) || kspring<=0){
          lineErr(i,'Spring beams need k=... with k>0.');
          continue;
        }
        tmpBeams.push({
          id,
          nodeA:ni,
          nodeB:nj,
          type:'spring',
          k:kspring,
          up:parms.up||null,
          rigid:false,
          releaseA:parms.releaseA,
          releaseB:parms.releaseB
        });
        continue;
      }
      if(hasLegacy && hasNew){ lineErr(i,'Pick one method per beam: either material/xsection or legacy E/A/Iy/Iz/J'); continue; }
      if(!hasLegacy && !hasNew){ lineErr(i,'Beam needs either material:.. + xsection:.. (or shape=.. dims) OR legacy E/A/Iy/Iz/J'); continue; }
      if(ni===nj){ lineErr(i,'Beam nodes must differ'); continue; }
      if(tmpBeams.some(b=>b.id===id)) lineErr(i,`Duplicate beam id ${id}`);

      if(hasLegacy){
        const E=+parms['e'], A=+parms['a'], Iy=+parms['iy'], Iz=+parms['iz'], J=+parms['j'];
        let G = (parms['g']!=null)? +parms['g'] : (isFinite(E) && isFinite(nuGlobal)? E/(2*(1+(+nuGlobal))) : NaN);
        if(!isFinite(E)||!isFinite(A)||!isFinite(Iy)||!isFinite(Iz)||!isFinite(J)){ lineErr(i,'Provide E, A, Iy, Iz, J'); continue; }
        tmpBeams.push({id,nodeA:ni,nodeB:nj,type:'beam',E,G:isFinite(G)?G:undefined,A,Iy,Iz,J, up:parms.up||null, rigid, releaseA:parms.releaseA, releaseB:parms.releaseB});
      } else {
        // New method: resolve libraries and/or inline shape
        const mname = methodNew.material;
        const mat = materialsLib[mname];
        if(!mat){ lineErr(i,`Unknown material '${mname}'`); continue; }
        const E=mat.E, G=E/(2*(1+mat.nu));

        let shapeKind=null, dims=null, upFromXsec=null;
        if(methodNew.xsec){
          const xs=xsectionsLib[methodNew.xsec];
          if(!xs){ lineErr(i,`Unknown xsection '${methodNew.xsec}'`); continue; }
          shapeKind=xs.shape; dims=xs.dims; upFromXsec=xs.up||null;
        }else{ // inline shape
          shapeKind=methodNew.shape; dims=methodNew.shapeDims; upFromXsec=null;
        }
        if(!shapeKind){ lineErr(i,'shape=... required for inline xsection'); continue; }

        // Compute section properties from dims
        const props = computeSectionProps(shapeKind, dims);
        if(!props){ lineErr(i,`Invalid dimensions for shape '${shapeKind}'`); continue; }
        const {A,Iy,Iz,J} = props;
        const up = (parms.up || upFromXsec || null);

        tmpBeams.push({
          id,nodeA:ni,nodeB:nj,E,G,A,Iy,Iz,J, up, rigid,
          releaseA:parms.releaseA, releaseB:parms.releaseB,
          xsec:{kind:shapeKind, dims:props.dims},
          material: mname,
          type:'beam'
        });
      }
    } else if(section==='conditions'){
      const re=/^\s*((\d+))\s*:\s*([a-zA-Z_]+)(.*)$/i;
      const mm=s.match(re);
      if(!mm){ lineErr(i,'Condition:  2: force Fx= Fy= Fz= Mx= My= Mz='); continue; }
      const nid=parseInt(mm[2],10);
      const type=mm[3].toLowerCase();
      const tail=(mm[4]||'').trim();
      const cond={type};
      tail.split(/\s+/).filter(Boolean).forEach(tok=>{
        const kv=tok.split('=');
        if(kv.length===2){
          const k=kv[0].toLowerCase(), v=kv[1];
          if(k==='axis'){ cond.axis=v.toLowerCase(); }
          else cond[k]=parseFloat(v);
        }
      });
      const ok=['fixed','pinned','slider','free','force','bushing_ground'];
      if(!ok.includes(type)){ lineErr(i,`Unsupported condition '${type}'`); }
      if(type==='slider' && !['x','y','z'].includes(cond.axis||'')) lineErr(i,'Slider needs axis=x|y|z');
      if(type==='force'){ ['fx','fy','fz','mx','my','mz'].forEach(k=>cond[k]=isFinite(cond[k])?cond[k]:0); }
      if(type==='bushing_ground'){ ['kx','ky','kz','krx','kry','krz'].forEach(k=>{ cond[k]=isFinite(cond[k])?Math.max(0,cond[k]):0; }); }
      if(!tmpConds[nid]) tmpConds[nid]=[]; tmpConds[nid].push(cond);
    }
  }

  const idset=new Set(tmpNodes.map(n=>n.id));
  tmpBeams.forEach(b=>{
    if(!idset.has(b.nodeA)||!idset.has(b.nodeB)){
      errs.push(`Beam ${b.id} references missing node(s)`);
    }else{
      const na=tmpNodes.find(n=>n.id===b.nodeA), nb=tmpNodes.find(n=>n.id===b.nodeB);
      const L=Math.hypot(nb.x-na.x, nb.y-na.y, nb.z-na.z);
      if(L<1e-9) errs.push(`Beam ${b.id} has zero length`);
    }
  });
  Object.entries(tmpConds).forEach(([nid,arr])=>{
    const support=['fixed','pinned','slider','bushing_ground'];
    const supCount=arr.filter(c=>support.includes(c.type)).length;
    if(supCount>1) errs.push(`Node ${nid}: multiple support-like conditions not allowed`);
    const hasFree = arr.some(c=>c.type==='free');
    if(hasFree && arr.length>1) errs.push(`Node ${nid}: 'free' cannot combine with other conditions`);
  });

  return {errors:errs, model:{nodes:tmpNodes,beams:tmpBeams,conditions:tmpConds,masses:tmpMasses}, libraries:{materials:materialsLib, xsections:xsectionsLib}, exagOverride, nuGlobal};
}

/* =========================
   LA Helpers
   ========================= */
function mul(A,B){
  const r=A.length,c=A[0].length, rb=B.length, cb=B[0].length;
  if(c!==rb) throw new Error('bad dims');
  const R=Array.from({length:r},()=>Array(cb).fill(0));
  for(let i=0;i<r;i++) for(let k=0;k<c;k++){
    const aik=A[i][k]; if(aik===0) continue;
    for(let j=0;j<cb;j++) R[i][j]+=aik*B[k][j];
  }
  return R;
}
function tr(A){
  const r=A.length,c=A[0].length;
  const T=Array.from({length:c},()=>Array(r).fill(0));
  for(let i=0;i<r;i++) for(let j=0;j<c;j++) T[j][i]=A[i][j];
  return T;
}
function gauss(A,b){
  const n=A.length;
  const aug=A.map((row,i)=>[...row,b[i]]);
  for(let p=0;p<n;p++){
    let max=p; for(let i=p+1;i<n;i++) if(Math.abs(aug[i][p])>Math.abs(aug[max][p])) max=i;
    if(Math.abs(aug[max][p])<1e-12) return null;
    [aug[p],aug[max]]=[aug[max],aug[p]];
    const piv=aug[p][p];
    for(let j=p;j<=n;j++) aug[p][j]/=piv;
    for(let i=p+1;i<n;i++){
      const a=aug[i][p]; if(a===0) continue;
      for(let j=p;j<=n;j++) aug[i][j]-=a*aug[p][j];
    }
  }
  const x=new Array(n).fill(0);
  for(let i=n-1;i>=0;i--){
    let s=0; for(let j=i+1;j<n;j++) s+=aug[i][j]*x[j];
    x[i]=aug[i][n]-s;
  }
  return x;
}

function cloneMatrix(mat){
  return mat.map(row=>row.slice());
}

function jacobiEigenSym(matrix, tolerance=1e-9, maxIterations=200){
  const n=matrix.length;
  const A=cloneMatrix(matrix);
  const V=Array.from({length:n},(_,i)=>{
    const row=new Array(n).fill(0);
    row[i]=1;
    return row;
  });
  for(let iter=0; iter<maxIterations; iter++){
    let p=0,q=1,maxVal=0;
    for(let i=0;i<n;i++){
      for(let j=i+1;j<n;j++){
        const val=Math.abs(A[i][j]);
        if(val>maxVal){ maxVal=val; p=i; q=j; }
      }
    }
    if(maxVal<tolerance) break;
    const app=A[p][p];
    const aqq=A[q][q];
    const apq=A[p][q];
    const phi=0.5*Math.atan2(2*apq, aqq-app);
    const c=Math.cos(phi);
    const s=Math.sin(phi);

    for(let j=0;j<n;j++){
      if(j!==p && j!==q){
        const apj=A[p][j];
        const aqj=A[q][j];
        const newApj=c*apj - s*aqj;
        const newAqj=s*apj + c*aqj;
        A[p][j]=newApj;
        A[j][p]=newApj;
        A[q][j]=newAqj;
        A[j][q]=newAqj;
      }
    }
    const appNew=c*c*app - 2*s*c*apq + s*s*aqq;
    const aqqNew=s*s*app + 2*s*c*apq + c*c*aqq;
    A[p][p]=appNew;
    A[q][q]=aqqNew;
    A[p][q]=0;
    A[q][p]=0;

    for(let j=0;j<n;j++){
      const vip=V[j][p];
      const viq=V[j][q];
      V[j][p]=c*vip - s*viq;
      V[j][q]=s*vip + c*viq;
    }
  }
  const eigenvalues=A.map((row,i)=>row[i]);
  return {values:eigenvalues, vectors:V};
}

function scaleMatrix(mat, factor){
  return mat.map(row=>row.map(v=>v*factor));
}

function buildScaledStiffness(Kff, Mdiag, floor=1e-9){
  const n=Kff.length;
  const invSqrt= Mdiag.map(m=>1/Math.sqrt(Math.max(m, floor)));
  const A=Array.from({length:n},()=>Array(n).fill(0));
  for(let i=0;i<n;i++){
    for(let j=0;j<n;j++){
      A[i][j]=Kff[i][j]*invSqrt[i]*invSqrt[j];
    }
  }
  return {matrix:A, invSqrt};
}

function subtractOmegaMass(Kff, Mdiag, omega){
  const n=Kff.length;
  const A=cloneMatrix(Kff);
  const omega2=omega*omega;
  for(let i=0;i<n;i++){
    A[i][i]-=omega2*Mdiag[i];
  }
  return A;
}

function solveComplexSystem(A,B,fVec){
  const n=A.length;
  const size=2*n;
  const block=Array.from({length:size},()=>Array(size).fill(0));
  const rhs=new Array(size).fill(0);
  for(let i=0;i<n;i++){
    rhs[i]=fVec[i];
    for(let j=0;j<n;j++){
      block[i][j]=A[i][j];
      block[i][j+n]=-B[i][j];
      block[i+n][j]=B[i][j];
      block[i+n][j+n]=A[i][j];
    }
  }
  const sol=gauss(block,rhs);
  if(!sol) return null;
  return {
    real: sol.slice(0,n),
    imag: sol.slice(n)
  };
}

/* =========================
   3D Beam (12x12) Utilities with Releases
   ========================= */
function normalize(v){ const L=Math.hypot(v[0],v[1],v[2]); return (L>0)?[v[0]/L,v[1]/L,v[2]/L]:[0,0,0]; }
function cross(a,b){ return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
function dot(a,b){ return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
function crossMatrix(v){
  return [
    [0, -v[2], v[1]],
    [v[2], 0, -v[0]],
    [-v[1], v[0], 0],
  ];
}

function beamRotation(pA,pB, upHint){
  const ex = normalize([pB.x-pA.x, pB.y-pA.y, pB.z-pA.z]);
  let g = upHint ? normalize(upHint) : [0,0,1];
  if(Math.abs(dot(ex,g))>0.999){ g=[0,1,0]; if(Math.abs(dot(ex,g))>0.999) g=[1,0,0]; }
  const ez = normalize(cross(ex, g));
  const ey = normalize(cross(ez, ex));
  return [
    [ex[0], ex[1], ex[2]],
    [ey[0], ey[1], ey[2]],
    [ez[0], ez[1], ez[2]],
  ];
}

function kLocal3D(E,G,A,Iy,Iz,J,L){
  const k=Array.from({length:12},()=>Array(12).fill(0));
  const EA_L = E*A/L;
  const GJ_L = G*J/L;
  const EIy = E*Iy, EIz = E*Iz;
  const EIyL  = EIy/L,  EIyL2 = EIy/(L*L),  EIyL3 = EIy/(L*L*L);
  const EIzL  = EIz/L,  EIzL2 = EIz/(L*L),  EIzL3 = EIz/(L*L*L);

  const U=0,V=1,W=2,RX=3,RY=4,RZ=5, U2=6,V2=7,W2=8,RX2=9,RY2=10,RZ2=11;

  function add(i,j,val){
    k[i][j]+=val;
    if(i!==j) k[j][i]+=val; // symmetric
  }

  // Axial
  add(U,U, EA_L); add(U,U2, -EA_L); add(U2,U2, EA_L);

  // Torsion
  add(RX,RX, GJ_L); add(RX,RX2, -GJ_L); add(RX2,RX2, GJ_L);

  // Bending about local z (V, RZ) -> EIz
  add(V,V, 12*EIzL3); add(V,V2, -12*EIzL3);
  add(V,RZ, 6*EIzL2); add(V,RZ2, 6*EIzL2);
  add(RZ,RZ, 4*EIzL); add(RZ,RZ2, 2*EIzL);
  add(V2,RZ, -6*EIzL2); add(V2,RZ2, -6*EIzL2);
  add(V2,V2, 12*EIzL3);
  add(RZ2,RZ2, 4*EIzL);

  // Bending about local y (W, RY) -> EIy
  add(W,W, 12*EIyL3); add(W,W2, -12*EIyL3);
  add(W,RY, -6*EIyL2); add(W,RY2, -6*EIyL2);
  add(RY,RY, 4*EIyL); add(RY,RY2, 2*EIyL);
  add(W2,RY, 6*EIyL2); add(W2,RY2, 6*EIyL2);
  add(W2,W2, 12*EIyL3);
  add(RY2,RY2, 4*EIyL);

  return k;
}

function T12(R){
  const T=Array.from({length:12},()=>Array(12).fill(0));
  for(let blk=0; blk<4; blk++){
    for(let r=0;r<3;r++) for(let c=0;c<3;c++){
      T[3*blk+r][3*blk+c] = R[r][c];
    }
  }
  return T;
}

function zeroRowCol(M,i){
  for(let c=0;c<M.length;c++) M[i][c]=0;
  for(let r=0;r<M.length;r++) M[r][i]=0;
}
function applyReleasesToLocalK(k, relA, relB){
  const mapA={rx:3, ry:4, rz:5};
  const mapB={rx:9, ry:10, rz:11};
  if(relA?.rx) zeroRowCol(k,mapA.rx);
  if(relA?.ry) zeroRowCol(k,mapA.ry);
  if(relA?.rz) zeroRowCol(k,mapA.rz);
  if(relB?.rx) zeroRowCol(k,mapB.rx);
  if(relB?.ry) zeroRowCol(k,mapB.ry);
  if(relB?.rz) zeroRowCol(k,mapB.rz);
}

const RIGID_TRANS_PENALTY = 1e12;
const RIGID_ROT_PENALTY = 1e9;

/* =========================
   System Assembly (K, M, loads, constraints)
   ========================= */
function assembleSystem(model){
  const N=model.nodes||[], E=model.beams||[], C=model.conditions||{};
  if(E.length===0) throw new Error('No beams defined');
  const hasSupport = Object.values(C).some(conds =>
    conds.some(c=>['fixed','pinned','slider'].includes(c.type) || c.type==='bushing_ground')
  );
  if(!hasSupport) throw new Error('Add at least one support/bushing');

  const idxOf={}; N.forEach((n,i)=>idxOf[n.id]=i);
  const n=N.length, dof=6*n;
  const K=Array.from({length:dof},()=>Array(dof).fill(0));
  const F=new Array(dof).fill(0);
  const fixed=new Set();
  const dofIndex=i=>[6*i+0,6*i+1,6*i+2,6*i+3,6*i+4,6*i+5];
  const massDiag=new Array(dof).fill(0);
  const masses = model.masses || nodeMasses || {};

  N.forEach((node, i)=>{
    const m = masses[node.id] || {};
    const [ux,uy,uz,rx,ry,rz] = dofIndex(i);
    if(isFinite(m.mx)) massDiag[ux] = m.mx;
    if(isFinite(m.my)) massDiag[uy] = m.my;
    if(isFinite(m.mz)) massDiag[uz] = m.mz;
    if(isFinite(m.ix)) massDiag[rx] = m.ix;
    if(isFinite(m.iy)) massDiag[ry] = m.iy;
    if(isFinite(m.iz)) massDiag[rz] = m.iz;
  });

  for(const e of E){
    const ia=idxOf[e.nodeA], ib=idxOf[e.nodeB];
    const na=N[ia], nb=N[ib];
    const L=Math.hypot(nb.x-na.x, nb.y-na.y, nb.z-na.z); if(L<1e-12) continue;

    const type = e.type || 'beam';
    if(type==='spring'){
      const kspring = e.k;
      if(!isFinite(kspring) || kspring<=0) continue;
      const dir = normalize([nb.x-na.x, nb.y-na.y, nb.z-na.z]);
      // project stiffness along spring axis so only axial forces are resisted
      const outer = [
        [dir[0]*dir[0], dir[0]*dir[1], dir[0]*dir[2]],
        [dir[1]*dir[0], dir[1]*dir[1], dir[1]*dir[2]],
        [dir[2]*dir[0], dir[2]*dir[1], dir[2]*dir[2]],
      ];
      const idxA = dofIndex(ia);
      const idxB = dofIndex(ib);
      for(let r=0;r<3;r++){
        for(let c=0;c<3;c++){
          const val = kspring * outer[r][c];
          K[idxA[r]][idxA[c]] += val;
          K[idxA[r]][idxB[c]] -= val;
          K[idxB[r]][idxA[c]] -= val;
          K[idxB[r]][idxB[c]] += val;
        }
      }
      continue;
    } else if(type==='rigidlink'){
      const idxA = dofIndex(ia);
      const idxB = dofIndex(ib);
      const dVec = [nb.x-na.x, nb.y-na.y, nb.z-na.z];
      const H = crossMatrix(dVec);
      const addConstraint = (coeffs, penalty)=>{
        for(let a=0;a<coeffs.length;a++){
          const iaIdx = coeffs[a].idx;
          const ca = coeffs[a].coef;
          if(ca===0) continue;
          for(let b=0;b<coeffs.length;b++){
            const ibIdx = coeffs[b].idx;
            const cb = coeffs[b].coef;
            if(cb===0) continue;
            K[iaIdx][ibIdx] += penalty * ca * cb;
          }
        }
      };
      for(let k=0;k<3;k++){
        const coeffs=[
          {idx: idxB[k], coef: 1},
          {idx: idxA[k], coef: -1},
          {idx: idxA[3+0], coef: -0.5*H[k][0]},
          {idx: idxA[3+1], coef: -0.5*H[k][1]},
          {idx: idxA[3+2], coef: -0.5*H[k][2]},
          {idx: idxB[3+0], coef: -0.5*H[k][0]},
          {idx: idxB[3+1], coef: -0.5*H[k][1]},
          {idx: idxB[3+2], coef: -0.5*H[k][2]},
        ];
        addConstraint(coeffs, RIGID_TRANS_PENALTY);
      }
      for(let r=0;r<3;r++){
        const coeffs=[
          {idx: idxB[3+r], coef: 1},
          {idx: idxA[3+r], coef: -1},
        ];
        addConstraint(coeffs, RIGID_ROT_PENALTY);
      }
      continue;
    }

    const R = beamRotation(na, nb, e.up);
    // G handling and rigid scaling
    const Gbase = (e.G!=null && isFinite(e.G)) ? e.G :
                  (isFinite(e.E) && isFinite(nuGlobal)) ? e.E/(2*(1+nuGlobal)) : (e.E/2.6);
    const RIGID=1e6;
    const Eeff = e.rigid ? e.E*RIGID : e.E;
    const Geff = e.rigid ? Gbase*RIGID : Gbase;

    const kL = kLocal3D(Eeff, Geff, e.A, e.Iy, e.Iz, e.J, L);
    // End releases disabled
    const T  = T12(R);
    const kG = mul(tr(T), mul(kL, T));

    const map=[...dofIndex(ia), ...dofIndex(ib)];
    for(let p=0;p<12;p++) for(let q=0;q<12;q++){
      K[map[p]][map[q]] += kG[p][q];
    }
  }

  for(const nidStr of Object.keys(C)){
    const nid=parseInt(nidStr,10);
    const i=idxOf[nid]; if(i===undefined) continue;
    const [ux,uy,uz,rx,ry,rz]=dofIndex(i);
    for(const c of C[nid]){
      if(c.type==='fixed'){
        [ux,uy,uz,rx,ry,rz].forEach(d=>fixed.add(d));
      }else if(c.type==='pinned'){
        [ux,uy,uz].forEach(d=>fixed.add(d));
      }else if(c.type==='slider'){
        if(c.axis==='x'){ fixed.add(uy); fixed.add(uz); }
        else if(c.axis==='y'){ fixed.add(ux); fixed.add(uz); }
        else { fixed.add(ux); fixed.add(uy); }
      }else if(c.type==='force'){
        F[ux]+= (isFinite(c.fx)?c.fx:0);
        F[uy]+= (isFinite(c.fy)?c.fy:0);
        F[uz]+= (isFinite(c.fz)?c.fz:0);
        F[rx]+= (isFinite(c.mx)?c.mx:0);
        F[ry]+= (isFinite(c.my)?c.my:0);
        F[rz]+= (isFinite(c.mz)?c.mz:0);
      }else if(c.type==='bushing_ground'){
        if(isFinite(c.kx))  K[ux][ux]+=c.kx;
        if(isFinite(c.ky))  K[uy][uy]+=c.ky;
        if(isFinite(c.kz))  K[uz][uz]+=c.kz;
        if(isFinite(c.krx)) K[rx][rx]+=c.krx;
        if(isFinite(c.kry)) K[ry][ry]+=c.kry;
        if(isFinite(c.krz)) K[rz][rz]+=c.krz;
      }
    }
  }

  const free=[]; for(let d=0; d<dof; d++) if(!fixed.has(d)) free.push(d);
  if(free.length===0) throw new Error('All DOFs are fixed');

  return {K, F, fixed, free, idxOf, dofIndex, massDiag, dof};
}

/* =========================
   Solver (3D) with Rigid + Releases
   ========================= */
async function solve3D(model, progressCb){
  await notifyProgress(progressCb, 0.05,'Assembling system…');
  const assembly = assembleSystem(model);
  await notifyProgress(progressCb, 0.3,'Forming reduced system…');
  const {K, F, free, dofIndex, massDiag} = assembly;
  const dof = assembly.dof;
  const fixed = assembly.fixed;
  const idxOf = assembly.idxOf;
  const N=model.nodes, E=model.beams||[], C=model.conditions||{};
  const freeCount = free.length;

  const Kred=Array.from({length:freeCount},()=>Array(freeCount).fill(0));
  const Fred=new Array(freeCount).fill(0);
  for(let p=0;p<freeCount;p++){
    Fred[p]=F[free[p]];
    for(let q=0;q<freeCount;q++) Kred[p][q]=K[free[p]][free[q]];
  }
  await notifyProgress(progressCb, 0.55,'Solving linear system…');
  const ured=gauss(Kred,Fred);
  if(!ured) throw new Error('Unstable structure (singular matrix)');

  await notifyProgress(progressCb, 0.7,'Back-substituting displacements…');
  const u=new Array(dof).fill(0);
  for(let p=0;p<freeCount;p++) u[free[p]]=ured[p];

  await notifyProgress(progressCb, 0.8,'Recovering reactions…');
  const reactions={};
  for(const nidStr of Object.keys(C||{})){
    const nid=parseInt(nidStr,10);
    const i=idxOf[nid]; if(i===undefined) continue;
    const [ux,uy,uz,rx,ry,rz]=dofIndex(i);
    const conds=C[nid];
    let R6=[0,0,0,0,0,0];
    const restr=[false,false,false,false,false,false];

    if(conds.some(c=>c.type==='fixed')){ restr.fill(true); }
    else{
      if(conds.some(c=>c.type==='pinned')) { restr[0]=restr[1]=restr[2]=true; }
      const slid=conds.find(c=>c.type==='slider');
      if(slid){
        if(slid.axis==='x'){ restr[1]=true; restr[2]=true; }
        else if(slid.axis==='y'){ restr[0]=true; restr[2]=true; }
        else { restr[0]=true; restr[1]=true; }
      }
    }

    const di=[ux,uy,uz,rx,ry,rz];
    for(let a=0;a<6;a++){
      if(!restr[a]) continue;
      let Ra=0; for(let d=0; d<dof; d++) Ra += K[di[a]][d]*u[d];
      R6[a]= Ra - F[di[a]];
    }
    const spr=conds.find(c=>c.type==='bushing_ground');
    if(spr){
      R6[0]+=-((spr.kx)||0)*u[ux];
      R6[1]+=-((spr.ky)||0)*u[uy];
      R6[2]+=-((spr.kz)||0)*u[uz];
      R6[3]+=-((spr.krx)||0)*u[rx];
      R6[4]+=-((spr.kry)||0)*u[ry];
      R6[5]+=-((spr.krz)||0)*u[rz];
    }
    reactions[nid]={Fx:R6[0],Fy:R6[1],Fz:R6[2],Mx:R6[3],My:R6[4],Mz:R6[5]};
  }

  const displacements = Object.fromEntries(
    N.map((n, i) => [n.id, {
      ux: u[6*i+0], uy: u[6*i+1], uz: u[6*i+2],
      rx: u[6*i+3], ry: u[6*i+4], rz: u[6*i+5],
    }])
  );

  await notifyProgress(progressCb, 0.9,'Computing element forces…');
  const beamForces={};
  const beamForcesLocal={};
  for(const e of E){
    const ia=idxOf[e.nodeA], ib=idxOf[e.nodeB];
    const na=N[ia], nb=N[ib];
    const L=Math.hypot(nb.x-na.x, nb.y-na.y, nb.z-na.z); if(L<1e-12) continue;
    const type = e.type || 'beam';
    if(type==='spring'){
      const kspring = e.k;
      if(!isFinite(kspring) || kspring<=0) continue;
      const dir = normalize([nb.x-na.x, nb.y-na.y, nb.z-na.z]);
      const dispA = [u[6*ia+0], u[6*ia+1], u[6*ia+2]];
      const dispB = [u[6*ib+0], u[6*ib+1], u[6*ib+2]];
      const rel = ((dispB[0]-dispA[0])*dir[0]) + ((dispB[1]-dispA[1])*dir[1]) + ((dispB[2]-dispA[2])*dir[2]);
      const axial = kspring * rel;
      const global = [dir[0]*axial, dir[1]*axial, dir[2]*axial];
      beamForces[e.id]={
        endA:{Fx:global[0], Fy:global[1], Fz:global[2], Mx:0, My:0, Mz:0},
        endB:{Fx:-global[0], Fy:-global[1], Fz:-global[2], Mx:0, My:0, Mz:0},
      };
      beamForcesLocal[e.id]={
        endA:{Fx:axial, Fy:0, Fz:0, Mx:0, My:0, Mz:0},
        endB:{Fx:-axial, Fy:0, Fz:0, Mx:0, My:0, Mz:0},
      };
      continue;
    } else if(type==='rigidlink'){
      const idxA = dofIndex(ia);
      const idxB = dofIndex(ib);
      const dispA = [u[idxA[0]], u[idxA[1]], u[idxA[2]]];
      const dispB = [u[idxB[0]], u[idxB[1]], u[idxB[2]]];
      const rotA = [u[idxA[3]], u[idxA[4]], u[idxA[5]]];
      const rotB = [u[idxB[3]], u[idxB[4]], u[idxB[5]]];
      const dVec = [nb.x-na.x, nb.y-na.y, nb.z-na.z];
      const H = crossMatrix(dVec);
      const wAvg=[
        0.5*(rotA[0]+rotB[0]),
        0.5*(rotA[1]+rotB[1]),
        0.5*(rotA[2]+rotB[2]),
      ];
      const rigidTrans=[
        H[0][0]*wAvg[0] + H[0][1]*wAvg[1] + H[0][2]*wAvg[2],
        H[1][0]*wAvg[0] + H[1][1]*wAvg[1] + H[1][2]*wAvg[2],
        H[2][0]*wAvg[0] + H[2][1]*wAvg[1] + H[2][2]*wAvg[2],
      ];
      const diffTrans=[
        dispB[0]-dispA[0],
        dispB[1]-dispA[1],
        dispB[2]-dispA[2],
      ];
      const cTrans=[
        diffTrans[0]-rigidTrans[0],
        diffTrans[1]-rigidTrans[1],
        diffTrans[2]-rigidTrans[2],
      ];
      const diffRot=[
        rotB[0]-rotA[0],
        rotB[1]-rotA[1],
        rotB[2]-rotA[2],
      ];
      const loadA=[0,0,0,0,0,0];
      const loadB=[0,0,0,0,0,0];
      for(let k=0;k<3;k++){
        const c=cTrans[k];
        const pen=RIGID_TRANS_PENALTY * c;
        loadB[k] += pen;
        loadA[k] -= pen;
        loadA[3+0] += pen * (-0.5*H[k][0]);
        loadA[3+1] += pen * (-0.5*H[k][1]);
        loadA[3+2] += pen * (-0.5*H[k][2]);
        loadB[3+0] += pen * (-0.5*H[k][0]);
        loadB[3+1] += pen * (-0.5*H[k][1]);
        loadB[3+2] += pen * (-0.5*H[k][2]);
      }
      for(let r=0;r<3;r++){
        const c=diffRot[r];
        const pen=RIGID_ROT_PENALTY * c;
        loadB[3+r] += pen;
        loadA[3+r] -= pen;
      }
      beamForces[e.id]={
        endA:{Fx:loadA[0], Fy:loadA[1], Fz:loadA[2], Mx:loadA[3], My:loadA[4], Mz:loadA[5]},
        endB:{Fx:loadB[0], Fy:loadB[1], Fz:loadB[2], Mx:loadB[3], My:loadB[4], Mz:loadB[5]},
      };
      beamForcesLocal[e.id]=beamForces[e.id];
      continue;
    }

    const R=beamRotation(na,nb,e.up);
    const T=T12(R);
    const Gbase = (e.G!=null && isFinite(e.G)) ? e.G :
                  (isFinite(e.E) && isFinite(nuGlobal)) ? e.E/(2*(1+nuGlobal)) : (e.E/2.6);
    const RIGID=1e6, Eeff=e.rigid?e.E*RIGID:e.E, Geff=e.rigid?Gbase*RIGID:Gbase;
    const kL = kLocal3D(Eeff,Geff,e.A,e.Iy,e.Iz,e.J,L);
    // End releases disabled
    const u_g = [
      u[6*ia+0],u[6*ia+1],u[6*ia+2],u[6*ia+3],u[6*ia+4],u[6*ia+5],
      u[6*ib+0],u[6*ib+1],u[6*ib+2],u[6*ib+3],u[6*ib+4],u[6*ib+5],
    ].map(x=>[x]);
    const u_l = mul(T, u_g);
    const f_l = mul(kL, u_l);
    const f_g = mul(tr(T), f_l);
    beamForces[e.id]={
      endA:{Fx:f_g[0][0], Fy:f_g[1][0], Fz:f_g[2][0], Mx:f_g[3][0], My:f_g[4][0], Mz:f_g[5][0]},
      endB:{Fx:f_g[6][0], Fy:f_g[7][0], Fz:f_g[8][0], Mx:f_g[9][0], My:f_g[10][0], Mz:f_g[11][0]},
    };
    beamForcesLocal[e.id]={
      endA:{Fx:f_l[0][0], Fy:f_l[1][0], Fz:f_l[2][0], Mx:f_l[3][0], My:f_l[4][0], Mz:f_l[5][0]},
      endB:{Fx:f_l[6][0], Fy:f_l[7][0], Fz:f_l[8][0], Mx:f_l[9][0], My:f_l[10][0], Mz:f_l[11][0]},
    };
  }

  lastAssembly = {
    K,
    F,
    free,
    fixed,
    idxOf,
    dofIndex,
    massDiag,
    dof,
    nodes: model.nodes,
    beams: model.beams,
    conditions: model.conditions||{}
  };

  await notifyProgress(progressCb, 1,'Static solution complete');
  return {displacements,reactions,beamForces, beamForcesLocal, massDiag, freeDofs:free};
}

async function computeModalAndFrf(model, options, progressCb){
  await notifyProgress(progressCb, 0.02,'Assembling dynamics system…');
  const assembly = assembleSystem(model);
  lastAssembly = assembly;

  const {K, massDiag, free, dofIndex, idxOf, dof} = assembly;
  const nFree = free.length;
  if(nFree===0) throw new Error('All DOFs are fixed');

  const globalToFree=new Array(dof).fill(-1);
  free.forEach((d,i)=>globalToFree[d]=i);

  const Kff = free.map(i=> free.map(j=> K[i][j]));
  const Mff = free.map(i=> Math.max(massDiag[i], 1e-9));

  const driveNode = options.driveNode;
  const respNode = options.respNode;
  if(!Number.isFinite(driveNode) || idxOf[driveNode]==null) throw new Error('Drive node not found');
  if(!Number.isFinite(respNode) || idxOf[respNode]==null) throw new Error('Response node not found');
  const driveNodeIdx = idxOf[driveNode];
  const respNodeIdx = idxOf[respNode];
  const driveGlobalDofs = dofIndex(driveNodeIdx);
  const driveFreeIndices = driveGlobalDofs.map(g=>globalToFree[g]);
  const respGlobalDofs = dofIndex(respNodeIdx);
  const respFreeIndices = respGlobalDofs.map(g=>globalToFree[g]);
  if(driveFreeIndices.every(idx=>idx<0)) throw new Error('All drive DOFs are constrained by supports');
  if(respFreeIndices.every(idx=>idx<0)) throw new Error('All response DOFs are constrained by supports');

  const freqStart = Math.max(0, Number(options.freqStart) || 0);
  const freqEnd = Math.max(freqStart, Number(options.freqEnd) || freqStart);
  const samples = Math.max(2, Math.floor(Number(options.samples) || 200));

  const freqValues=[];
  const magSeries=DOF_KEYS.map(()=>[]);
  const phaseSeries=DOF_KEYS.map(()=>[]);

  await notifyProgress(progressCb, 0.08,'Computing modal basis…');
  const massScaled = buildScaledStiffness(Kff, Mff);
  const eigen = jacobiEigenSym(massScaled.matrix);
  const eigenPairs = eigen.values
    .map((lambda, idx)=>({lambda, idx}))
    .filter(pair=>pair.lambda>1e-9)
    .sort((a,b)=>a.lambda-b.lambda);
  const modes = eigenPairs.slice(0, Math.min(12, eigenPairs.length)).map((pair,i)=>({
    mode: i+1,
    freq: Math.sqrt(pair.lambda)/(2*Math.PI)
  }));

  await notifyProgress(progressCb, 0.15,'Sweeping frequencies…');
  for(let k=0;k<samples;k++){
    const t = samples===1 ? 0 : k/(samples-1);
    const freq = freqStart + (freqEnd - freqStart)*t;
    const omega = 2*Math.PI*freq;
    const A = subtractOmegaMass(Kff, Mff, omega);
    const B = scaleMatrix(Kff, omega * DAMPING_BETA);
    freqValues.push(freq);
    for(let dIndex=0; dIndex<DOF_KEYS.length; dIndex++){
      const driveFree = driveFreeIndices[dIndex];
      const respFree = respFreeIndices[dIndex];
      let real=0, imag=0;
      if(driveFree>=0){
        const vec = new Array(nFree).fill(0);
        vec[driveFree]=1;
        const sol = solveComplexSystem(A,B,vec);
        if(sol){
          const respIdx = respFree>=0 ? respFree : driveFree;
          if(respIdx>=0){
            real = sol.real[respIdx];
            imag = sol.imag[respIdx];
          }
        }
      }
      magSeries[dIndex].push(Math.hypot(real, imag));
      phaseSeries[dIndex].push(Math.atan2(imag, real));
    }
    if(typeof progressCb === 'function'){
      const updateEvery = Math.max(1, Math.floor(samples/60));
      if(k===samples-1 || k % updateEvery === 0){
        const frac = 0.15 + 0.8*((k+1)/samples);
        await notifyProgress(progressCb, Math.max(0, Math.min(1, frac)), `Frequency sweep ${k+1}/${samples}`);
      }
    }
  }
  await notifyProgress(progressCb, 0.98,'Finalizing results…');

  await notifyProgress(progressCb, 1,'Frequency response complete');
  return {
    freqs: freqValues,
    magnitudes: magSeries,
    phases: phaseSeries,
    modes,
    drive:{
      node: driveNode
    },
    response:{
      node: respNode
    }
  };
}

function renderDynamicsResults(data){
  if(!data){
    dynInfoEl.textContent='';
    const ctxMag=dynMagCanvas.getContext('2d'); ctxMag.clearRect(0,0,dynMagCanvas.width,dynMagCanvas.height);
    const ctxPhase=dynPhaseCanvas.getContext('2d'); ctxPhase.clearRect(0,0,dynPhaseCanvas.width,dynPhaseCanvas.height);
    chartStates.delete(dynMagCanvas);
    chartStates.delete(dynPhaseCanvas);
    return;
  }
  dynInfoEl.textContent = `Drive node: ${data.drive.node} • Response node: ${data.response.node}`;

  const freqValues = data.freqs;
  const phasesDeg = data.phases.map(series => series.map(v=>v*180/Math.PI));
  const normalize = !!dynNormalizeEl?.checked;
  const magSeriesList = DOF_KEYS.map((key, idx)=>{
    const magnitudes = data.magnitudes[idx] || [];
    let processed = magnitudes;
    if(normalize && magnitudes.length){
      const base = Math.abs(magnitudes[0]) > 1e-12 ? magnitudes[0] : 1;
      processed = magnitudes.map(v=> v/(base||1));
    }
    const peaks = findMagnitudePeaks(freqValues, magnitudes);
    const peakText = peaks.length ? peaks.map(p=>formatNoSci(p.freq)).join(', ') : '—';
    return {
      label: `${DOF_LABELS[idx]} [${DOF_UNITS[idx]}] (${peakText} Hz)`,
      color: DOF_COLORS[idx],
      values: processed
    };
  });
  const phaseSeriesList = DOF_KEYS.map((key, idx)=>({
    label: `${DOF_LABELS[idx]} (${DOF_UNITS[idx]})`,
    color: DOF_COLORS[idx],
    values: phasesDeg[idx]
  }));
  drawLineChart(dynMagCanvas, freqValues, magSeriesList, {yLabel:'|H|', legend:true, logX:true, logY:true, yTickFormat:'sci', hoverable:true});
  drawLineChart(dynPhaseCanvas, freqValues, phaseSeriesList, {yLabel:'Phase (deg)', yTicks:[-180,-90,0,90,180], legend:false, logX:true, hoverable:true});
}

function drawLineChart(canvas, xVals, seriesList, opts={}){
  const hoverX = Object.prototype.hasOwnProperty.call(opts,'hoverX') ? opts.hoverX : null;
  const baseOpts = {...opts};
  delete baseOpts.hoverX;
  const ctx=canvas.getContext('2d');
  const dpr=window.devicePixelRatio||1;
  const computedStyle = window.getComputedStyle(canvas);
  const parentWidth = canvas.clientWidth || canvas.parentElement?.clientWidth || parseFloat(computedStyle.width) || 640;
  const cssHeight = parseFloat(computedStyle.height) || canvas.clientHeight || 320;
  const width = parentWidth;
  const height = cssHeight;

  canvas.width = Math.max(1, Math.floor(width*dpr));
  canvas.height = Math.max(1, Math.floor(height*dpr));
  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(dpr,dpr);
  ctx.clearRect(0,0,width,height);

  if(!xVals || !xVals.length || !seriesList || !seriesList.length){
    chartStates.delete(canvas);
    ctx.fillStyle='#cbd5dc';
    ctx.font='12px ui-monospace,Consolas,monospace';
    ctx.fillText('No data', width/2-24, height/2);
    return;
  }

  const padLeft=70, padRight=28, padTop=32, padBottom=44;
  const plotWidth = Math.max(1, width - padLeft - padRight);
  const plotHeight = Math.max(1, height - padTop - padBottom);
  const logX = !!opts.logX;
  const minPositive = 1e-9;
  const rawXMin = xVals[0];
  const rawXMax = xVals[xVals.length-1];
  const safeX = xVals.map(v=>Math.max(v, minPositive));
  const xMin = logX ? Math.log10(Math.max(rawXMin, minPositive)) : rawXMin;
  const xMax = logX ? Math.log10(Math.max(rawXMax, minPositive)) : rawXMax;

  let yAxisLog = !!opts.logY;
  const minPositiveY = 1e-12;
  const allValues = [];
  const positiveValues = [];
  seriesList.forEach(series=>{
    if(series && series.values){
      series.values.forEach(v=>{
        if(Number.isFinite(v)){
          allValues.push(v);
          if(v>0) positiveValues.push(v);
        }
      });
    }
  });
  if(yAxisLog && !positiveValues.length){
    yAxisLog=false;
  }
  let manualYTicks = null;
  if(!yAxisLog && opts.yTicks && opts.yTicks.length){
    manualYTicks = opts.yTicks;
  }

  let yMinRaw, yMaxRaw, yMinMap, yMaxMap;
  if(yAxisLog){
    const minPos = Math.min(...positiveValues);
    const maxPos = Math.max(...positiveValues);
    let safeMin = Math.max(minPos, minPositiveY);
    let safeMax = Math.max(maxPos, safeMin * 1.0001);
    yMinRaw = safeMin;
    yMaxRaw = safeMax;
    yMinMap = Math.log10(safeMin);
    yMaxMap = Math.log10(safeMax);
    if(!Number.isFinite(yMinMap) || !Number.isFinite(yMaxMap) || Math.abs(yMaxMap - yMinMap) < 1e-6){
      yMinMap = Math.log10(minPositiveY);
      yMaxMap = yMinMap + 2;
      yMinRaw = Math.pow(10, yMinMap);
      yMaxRaw = Math.pow(10, yMaxMap);
    }
  }else{
    if(allValues.length){
      yMinRaw = Math.min(...allValues);
      yMaxRaw = Math.max(...allValues);
    }else{
      yMinRaw = -1; yMaxRaw = 1;
    }
    if(manualYTicks){
      const tickMin = Math.min(...manualYTicks);
      const tickMax = Math.max(...manualYTicks);
      yMinRaw = Math.min(yMinRaw, tickMin);
      yMaxRaw = Math.max(yMaxRaw, tickMax);
    }
    if(!Number.isFinite(yMinRaw) || !Number.isFinite(yMaxRaw)){
      yMinRaw=-1; yMaxRaw=1;
    }
    if(Math.abs(yMaxRaw - yMinRaw) < 1e-12){
      const offset = (Math.abs(yMaxRaw) < 1 ? 1 : Math.abs(yMaxRaw)*0.1);
      yMaxRaw += offset;
      yMinRaw -= offset;
    }
    yMinMap = yMinRaw;
    yMaxMap = yMaxRaw;
  }

  const minLogLinear = yAxisLog ? Math.pow(10, yMinMap) : null;

  const xToPx = xRaw => {
    const xVal = logX ? Math.log10(Math.max(xRaw, minPositive)) : xRaw;
    return padLeft + ((xVal - xMin) / (xMax - xMin || 1)) * plotWidth;
  };
  const yToPx = yRaw => {
    const yVal = yAxisLog ? Math.log10(Math.max(yRaw, minLogLinear)) : yRaw;
    return padTop + (1 - (yVal - yMinMap) / (yMaxMap - yMinMap || 1)) * plotHeight;
  };

  ctx.strokeStyle='#2d343a';
  ctx.lineWidth=1;
  ctx.beginPath();
  ctx.moveTo(padLeft, padTop);
  ctx.lineTo(padLeft, padTop + plotHeight);
  ctx.lineTo(padLeft + plotWidth, padTop + plotHeight);
  ctx.stroke();

  ctx.fillStyle='#637180';
  ctx.font='11px ui-monospace,Consolas,monospace';
  if(yAxisLog){
    const minVal = Math.pow(10, yMinMap);
    const maxVal = Math.pow(10, yMaxMap);
    const EPS=1e-9;
    const minExp = Math.floor(Math.log10(minVal));
    const maxExp = Math.floor(Math.log10(maxVal));
    const tickVals=[];
    const formatLabel = opts.yTickFormat==='sci' ? formatSci : formatNoSci;
    for(let exp=minExp; exp<=maxExp; exp++){
      const major = Math.pow(10, exp);
      if(major >= minVal - EPS && major <= maxVal + EPS){
        tickVals.push({value:major, label:formatLabel(major), major:true});
      }
      if(exp < maxExp){
        for(let m=2; m<10; m++){
          const minor = major * m;
          if(minor > 10*major + EPS || minor > maxVal + EPS) break;
          if(minor >= minVal - EPS){ tickVals.push({value:minor, label:null, major:false}); }
        }
      }
    }
    if(!tickVals.length){
      tickVals.push({value:minVal, label:formatLabel(minVal), major:true});
      tickVals.push({value:maxVal, label:formatLabel(maxVal), major:true});
    }
    tickVals.sort((a,b)=>a.value-b.value);
    tickVals.forEach(tick=>{
      const val=tick.value;
      const yPx = yToPx(val);
      ctx.beginPath();
      ctx.moveTo(padLeft- (tick.label?4:2), yPx);
      ctx.lineTo(padLeft, yPx);
      ctx.stroke();
      if(tick.major){
        ctx.save();
        ctx.strokeStyle='rgba(148, 163, 184, 0.18)';
        ctx.lineWidth=1;
        ctx.setLineDash([4,4]);
        ctx.beginPath();
        ctx.moveTo(padLeft, yPx);
        ctx.lineTo(padLeft + plotWidth, yPx);
        ctx.stroke();
        ctx.restore();
      }
      if(tick.label){
        const labelWidth = ctx.measureText(tick.label).width;
        ctx.fillText(tick.label, padLeft - 8 - labelWidth, yPx+4);
      }
    });
  }else{
    const tickCount = manualYTicks ? manualYTicks.length : 5;
    for(let i=0;i<tickCount;i++){
      const yVal = manualYTicks ? manualYTicks[i] : (yMinRaw + ((tickCount===1?0:i/(tickCount-1))*(yMaxRaw-yMinRaw)));
      const yPx = yToPx(yVal);
      ctx.beginPath();
      ctx.moveTo(padLeft-4, yPx);
      ctx.lineTo(padLeft, yPx);
      ctx.stroke();
      ctx.fillText(formatTick(yVal), 4, yPx+4);
      ctx.save();
      ctx.strokeStyle='rgba(148, 163, 184, 0.18)';
      ctx.lineWidth=1;
      ctx.setLineDash([4,4]);
      ctx.beginPath();
      ctx.moveTo(padLeft, yPx);
      ctx.lineTo(padLeft + plotWidth, yPx);
      ctx.stroke();
      ctx.restore();
    }
  }

  if(logX){
    const minVal = Math.pow(10, xMin);
    const maxVal = Math.pow(10, xMax);
    const tickValues=[];
    const EPS=1e-9;
    const addTick=(val, major=true)=>{
      if(!Number.isFinite(val)) return;
      if(val < minVal - EPS || val > maxVal + EPS) return;
      for(const existing of tickValues){
        if(Math.abs(existing.value - val) <= Math.max(1, val)*1e-9) return;
      }
      tickValues.push({value:val, major});
    };
    const minExp = Math.floor(Math.log10(minVal));
    const maxExp = Math.floor(Math.log10(maxVal));
    for(let exp=minExp; exp<=maxExp; exp++){
      const base = Math.pow(10, exp);
      addTick(base, true);
      const decadeEnd = base*10;
      for(let m=2; m<10; m++){
        const minor = base * m;
        if(minor > decadeEnd + EPS || minor > maxVal + EPS) break;
        if(minor >= minVal - EPS){
          addTick(Number(minor.toPrecision(8)), false);
        }
      }
    }
    addTick(minVal);
    addTick(maxVal);
    tickValues.sort((a,b)=>a.value-b.value);
    tickValues.forEach(tick=>{
      const xPx = xToPx(tick.value);
      ctx.beginPath();
      ctx.moveTo(xPx, padTop + plotHeight);
      ctx.lineTo(xPx, padTop + plotHeight + 4);
      ctx.stroke();
      const isMajor = tick.major !== false;
      const label = (tick.value>=minVal-EPS && tick.value<=maxVal+EPS && isMajor) ? formatNoSci(tick.value) : null;
      if(label){
        const labelWidth = ctx.measureText(label).width;
        ctx.fillText(label, xPx - labelWidth/2, padTop + plotHeight + 20);
      }
      ctx.save();
      ctx.strokeStyle = 'rgba(148, 163, 184, 0.18)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4,4]);
      ctx.beginPath();
      ctx.moveTo(xPx, padTop);
      ctx.lineTo(xPx, padTop + plotHeight);
      ctx.stroke();
      ctx.restore();
    });
  }else{
    const xTickCount = Math.min(6, xVals.length);
    for(let i=0;i<xTickCount;i++){
      const denom = Math.max(1, xTickCount-1);
      const t = xTickCount === 1 ? 0 : i/denom;
      const xVal = xMin + t*(xMax-xMin);
      const xPx = xToPx(xVal);
      ctx.beginPath();
      ctx.moveTo(xPx, padTop + plotHeight);
      ctx.lineTo(xPx, padTop + plotHeight + 4);
      ctx.stroke();
      const label = formatNoSci(xVal);
      ctx.fillText(label, xPx - ctx.measureText(label).width/2, padTop + plotHeight + 20);
      ctx.save();
      ctx.strokeStyle='rgba(148, 163, 184, 0.18)';
      ctx.lineWidth=1;
      ctx.setLineDash([4,4]);
      ctx.beginPath();
      ctx.moveTo(xPx, padTop);
      ctx.lineTo(xPx, padTop + plotHeight);
      ctx.stroke();
      ctx.restore();
    }
  }

  seriesList.forEach(series=>{
    if(!series || !series.values) return;
    const color = series.color || '#4cc9f0';
    ctx.strokeStyle=color;
    ctx.lineWidth=1.8;
    ctx.beginPath();
    let penDown=false;
    for(let i=0;i<xVals.length;i++){
      const xVal = safeX[i];
      let yVal = series.values[i];
      if(!Number.isFinite(yVal)){
        penDown=false;
        continue;
      }
      if(yAxisLog){
        if(!(yVal>0)){
          yVal = minLogLinear;
        }
        if(!(yVal>0)){
          penDown=false;
          continue;
        }
      }
      const x=xToPx(xVal);
      const y=yToPx(yVal);
      if(!penDown){
        ctx.moveTo(x,y);
        penDown=true;
      }else{
        ctx.lineTo(x,y);
      }
    }
    ctx.stroke();
  });
  if(Number.isFinite(hoverX)){
    const xPx = xToPx(hoverX);
    if(xPx >= padLeft && xPx <= padLeft + plotWidth){
      ctx.save();
      ctx.setLineDash([4,4]);
      ctx.strokeStyle='rgba(76,201,240,0.75)';
      ctx.lineWidth=1;
      ctx.beginPath();
      ctx.moveTo(xPx, padTop);
      ctx.lineTo(xPx, padTop + plotHeight);
      ctx.stroke();
      ctx.setLineDash([]);
      const freqLabel = `f = ${formatNoSci(hoverX)} Hz`;
      ctx.font='12px ui-monospace,Consolas,monospace';
      const padding=6;
      const boxHeight=20;
      const textWidth = ctx.measureText(freqLabel).width;
      const boxWidth = textWidth + padding*2;
      let boxX = xPx - boxWidth/2;
      boxX = Math.min(Math.max(boxX, padLeft), padLeft + plotWidth - boxWidth);
      const boxY = padTop + plotHeight - boxHeight - 6;
      ctx.fillStyle='rgba(16,22,27,0.88)';
      ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
      ctx.strokeStyle='rgba(76,201,240,0.45)';
      ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
      ctx.fillStyle='#e7e9ec';
      ctx.fillText(freqLabel, boxX + padding, boxY + boxHeight - 6);
      ctx.restore();
    }
  }

  chartStates.set(canvas, {
    xVals,
    seriesList,
    opts: baseOpts,
    meta: {padLeft, padTop, plotWidth, plotHeight, logX, xMin, xMax},
    hoverX: Number.isFinite(hoverX) ? hoverX : null
  });
  if(baseOpts.hoverable) enableChartHover(canvas);
  ctx.fillStyle='#cbd5dc';
  ctx.font='12px ui-monospace,Consolas,monospace';
  if(opts.yLabel){
    ctx.fillText(opts.yLabel, padLeft + 6, padTop + 14);
  }

  if(opts.legend){
    const legendX = padLeft + 12;
    const legendY = padTop + plotHeight - 75;
    const lineHeight = 12;
    const legendFont = '10px ui-monospace,Consolas,monospace';
    seriesList.forEach((series, idx)=>{
      if(!series || !series.label) return;
      const y = legendY + idx*lineHeight;
      ctx.fillStyle=series.color || '#4cc9f0';
      ctx.fillRect(legendX, y-4, 12, 2);
      ctx.fillStyle='#cbd5dc';
      ctx.font=legendFont;
      ctx.fillText(series.label, legendX + 16, y+2);
    });
  }
}

function formatTick(val){
  if(!Number.isFinite(val)) return '—';
  const absVal = Math.abs(val);
  if(absVal === 0) return '0';
  if(absVal >= 1000 || absVal < 0.01){
    return val.toExponential(1);
  }
  if(absVal >= 100){
    return val.toFixed(0);
  }
  if(absVal >= 10){
    return val.toFixed(1);
  }
  return val.toFixed(2);
}

function formatNoSci(value){
  if(!Number.isFinite(value)) return '—';
  if(value === 0) return '0';
  const abs = Math.abs(value);
  let decimals;
  if(abs >= 100){
    decimals = 0;
  }else if(abs >= 10){
    decimals = 1;
  }else if(abs >= 1){
    decimals = 2;
  }else{
    decimals = Math.min(6, Math.ceil(-Math.log10(abs)));
  }
  let str = value.toFixed(decimals);
  str = str.replace(/(\.[0-9]*[1-9])0+$/,'$1');
  str = str.replace(/\.0+$/,'');
  if(str === '-0') str = '0';
  return str;
}

function formatSci(value){
  if(!Number.isFinite(value) || value===0) return '0';
  const exp = Math.floor(Math.log10(Math.abs(value)));
  const mant = value / Math.pow(10, exp);
  const mantStr = Math.abs(mant) >= 10 ? mant.toFixed(0) : Math.abs(mant) >= 1 ? mant.toFixed(1) : mant.toFixed(2);
  return `${mantStr.replace(/\.0+$/,'')}e${exp}`;
}

function formatSeconds(seconds){
  if(!Number.isFinite(seconds) || seconds <= 0) return '';
  if(seconds < 1){
    return `${seconds.toFixed(1)}s`;
  }
  if(seconds < 60){
    return `${Math.round(seconds)}s`;
  }
  const totalSeconds = Math.round(seconds);
  const minutes = Math.floor(totalSeconds / 60);
  const remSeconds = totalSeconds % 60;
  if(minutes < 60){
    return remSeconds ? `${minutes}m ${remSeconds}s` : `${minutes}m`;
  }
  const hours = Math.floor(minutes / 60);
  const remMinutes = minutes % 60;
  if(remMinutes === 0){
    return `${hours}h`;
  }
  return `${hours}h ${remMinutes}m`;
}

function findMagnitudePeaks(freqs, values){
  const peaks=[];
  if(!Array.isArray(freqs) || !Array.isArray(values) || freqs.length!==values.length) return peaks;
  if(values.length < 3) return peaks;
  for(let i=1;i<values.length-1;i++){
    const prev = values[i-1];
    const curr = values[i];
    const next = values[i+1];
    if(!Number.isFinite(curr)) continue;
    const prevVal = Number.isFinite(prev) ? prev : -Infinity;
    const nextVal = Number.isFinite(next) ? next : -Infinity;
    if(curr > prevVal && curr >= nextVal){
      peaks.push({freq: freqs[i], magnitude: curr});
    }
  }
  return peaks;
}

function computeDynamicMode(model, freqHz){
  const assembly = assembleSystem(model);
  const {K, F, free, dofIndex, massDiag} = assembly;
  const nodesLocal = model.nodes || [];
  const dof = assembly.dof;
  const freeCount = free.length;
  if(freeCount===0) throw new Error('All DOFs constrained');

  const globalToFree=new Array(dof).fill(-1);
  free.forEach((d,i)=>globalToFree[d]=i);

  const Kff = free.map(i=> free.map(j=> K[i][j]));
  const Mff = free.map(i=> Math.max(massDiag[i], 1e-9));
  const load = new Array(freeCount).fill(0);
  for(let p=0;p<freeCount;p++) load[p]=F[free[p]];

  const omega = 2*Math.PI*freqHz;
  const A = subtractOmegaMass(Kff, Mff, omega);
  const B = scaleMatrix(Kff, omega * DAMPING_BETA);
  const sol = solveComplexSystem(A,B,load);
  if(!sol) throw new Error('Dynamic system singular');

  const displacements={};
  nodesLocal.forEach((node, idx)=>{
    const base = 6*idx;
    const comp={};
    DOF_KEYS.forEach((key, localIdx)=>{
      const g = base + localIdx;
      const fi = globalToFree[g];
      if(fi>=0){
        const real = sol.real[fi]||0;
        const imag = sol.imag[fi]||0;
        comp[key]={amp:Math.hypot(real, imag), phase:Math.atan2(imag, real)};
      }else{
        comp[key]={amp:0, phase:0};
      }
    });
    displacements[node.id]=comp;
  });
  return {freq:freqHz, sourceOmega:omega, displacements};
}

function hasNonzeroAmplitude(mode){
  if(!mode || !mode.displacements) return false;
  for(const comp of Object.values(mode.displacements)){
    if(!comp) continue;
    for(const key of DOF_KEYS){
      if(comp[key]?.amp > 1e-12) return true;
    }
  }
  return false;
}

function enableChartHover(canvas){
  if(chartInteractive.has(canvas)) return;
  canvas.addEventListener('mousemove', event=>handleChartHoverMove(canvas, event));
  canvas.addEventListener('mouseleave', ()=>handleChartHoverLeave(canvas));
  chartInteractive.add(canvas);
}

function handleChartHoverMove(canvas, event){
  const state = chartStates.get(canvas);
  if(!state || !state.meta || !state.opts?.hoverable) return;
  const {meta} = state;
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const plotStart = meta.padLeft;
  const plotEnd = meta.padLeft + meta.plotWidth;
  if(x < plotStart || x > plotEnd){
    if(state.hoverX != null){
      drawLineChart(canvas, state.xVals, state.seriesList, {...state.opts});
    }
    return;
  }
  const t = Math.max(0, Math.min(1, (x - plotStart) / (meta.plotWidth || 1)));
  const freq = meta.logX ? Math.pow(10, meta.xMin + t*(meta.xMax - meta.xMin)) : meta.xMin + t*(meta.xMax - meta.xMin);
  if(state.hoverX != null){
    const rel = Math.abs(freq - state.hoverX) / Math.max(Math.abs(freq), Math.abs(state.hoverX), 1e-9);
    if(rel < 1e-4) return;
  }
  drawLineChart(canvas, state.xVals, state.seriesList, {...state.opts, hoverX:freq});
}

function handleChartHoverLeave(canvas){
  const state = chartStates.get(canvas);
  if(!state || state.hoverX == null) return;
  drawLineChart(canvas, state.xVals, state.seriesList, {...state.opts});
}

function toggleAnimation(){
  if(animationActive){
    stopAnimation();
  }else{
    startAnimation();
  }
}

function startAnimation(){
  if(animationActive) return;
  if(!results){
    setStatus('Solve first to animate.', false);
    return;
  }
  let freqHz = parseFloat(animateFreqEl.value);
  if(!isFinite(freqHz) || freqHz<=0){
    freqHz = 1;
    animateFreqEl.value = '1';
  }
  try{
    const model = {nodes, beams, conditions, masses: nodeMasses};
    const mode = computeDynamicMode(model, freqHz);
    if(!mode || !hasNonzeroAmplitude(mode)){
      setStatus('No dynamic response for the selected frequency.', false);
      return;
    }
    animationMode = {
      ...mode,
      sourceFreq: freqHz,
      omega: 2*Math.PI*ANIMATION_FREQ_HZ
    };
    computeFitScale({nodes,beams,conditions}, results);
  }catch(err){
    setStatus(`Dynamic solve failed: ${err.message||err}`, false);
    animationMode=null;
    return;
  }
  animationActive=true;
  btnAnimate.setAttribute('aria-pressed','true');
  btnAnimate.textContent='Stop Animation';
  animationStart=performance.now();
  animationTimeSec=0;
  setStatus(`Animating dynamic response at ${freqHz.toFixed(3)} Hz (displayed at ${ANIMATION_FREQ_HZ} Hz).`);
  animationRequest=requestAnimationFrame(stepAnimation);
}

function stopAnimation(){
  animationActive=false;
  if(animationRequest){ cancelAnimationFrame(animationRequest); animationRequest=null; }
  animationStart=0;
  animationTimeSec=0;
  animationMode=null;
  btnAnimate.setAttribute('aria-pressed','false');
  btnAnimate.textContent='Animate';
  setStatus('Animation stopped.');
  computeFitScale({nodes,beams,conditions}, results);
  render({nodes,beams,conditions}, results);
}

function stepAnimation(timestamp){
  if(!animationActive){
    return;
  }
  if(!animationStart) animationStart=timestamp;
  animationTimeSec = (timestamp - animationStart)/1000;
  render({nodes,beams,conditions}, results);
  animationRequest=requestAnimationFrame(stepAnimation);
}

function populateDynamicsSelectors(){
  const nodeOptions = nodes.map(n=>({value:String(n.id), label:`Node ${n.id}`}));
  const makeOptions = (options, prev) => {
    if(!options.length) return '<option value="">(none)</option>';
    return options.map(opt=>`<option value="${opt.value}" ${opt.value===prev?'selected':''}>${opt.label}</option>`).join('');
  };
  const prevDrive = dynDriveNodeEl.value;
  const prevResp = dynRespNodeEl.value;
  dynDriveNodeEl.innerHTML = makeOptions(nodeOptions, prevDrive);
  dynRespNodeEl.innerHTML = makeOptions(nodeOptions, prevResp);
  if(dynDriveNodeEl.selectedIndex===-1 && dynDriveNodeEl.options.length) dynDriveNodeEl.selectedIndex=0;
  if(dynRespNodeEl.selectedIndex===-1 && dynRespNodeEl.options.length) dynRespNodeEl.selectedIndex=0;
  if(!nodeOptions.length){
    dynDriveNodeEl.value='';
    dynRespNodeEl.value='';
  }
}

function handleDynamicsCompute(){
  dynErrorsEl.textContent='';
  try{
    const freqStart = Number(dynFreqStartEl.value);
    const freqEnd = Number(dynFreqEndEl.value);
    const samples = Number(dynFreqPointsEl.value);
    const driveNode = Number(dynDriveNodeEl.value);
    const respNode = Number(dynRespNodeEl.value);
    if(!nodes.length) throw new Error('Add nodes to the model first.');
    if(!Number.isFinite(freqStart) || !Number.isFinite(freqEnd)) throw new Error('Enter a valid frequency range.');
    if(freqStart<=0) throw new Error('Start frequency must be greater than zero for log scale.');
    if(freqEnd <= freqStart) throw new Error('End frequency must be greater than start frequency.');
    if(!Number.isFinite(samples) || samples < 2) throw new Error('Samples must be at least 2.');
    if(!Number.isFinite(driveNode) || !Number.isFinite(respNode)) throw new Error('Select drive and response nodes.');
    const model={nodes, beams, conditions, masses: nodeMasses};
    showProgress('Computing frequency response…', 0);
    setStatus('Computing frequency response…');
    requestAnimationFrame(()=>{
      requestAnimationFrame(async ()=>{
        try{
          const data = await computeModalAndFrf(model, {
            freqStart,
            freqEnd,
            samples,
            driveNode,
            respNode
          }, (fraction,label)=> showProgress(label || 'Computing frequency response…', fraction));
          lastFrfResults = data;
          renderDynamicsResults(data);
          setStatus('Frequency response computed.');
          hideProgress(400);
        }catch(err){
          renderDynamicsResults(null);
          dynErrorsEl.textContent = err.message || String(err);
          setStatus('Dynamics solve failed.', false);
          hideProgress(0);
        }
      });
    });
  }catch(err){
    renderDynamicsResults(null);
    dynErrorsEl.textContent = err.message || String(err);
    hideProgress(0);
  }
}

/* =========================
   Results UI
   ========================= */
function updateResultsUI(res, model){
  const dispList=document.getElementById('dispList');
  const reactionList=document.getElementById('reactionList');
  const beamForceList=document.getElementById('beamForceList');
  dispList.innerHTML=reactionList.innerHTML=beamForceList.innerHTML='';

  nNodesEl.textContent=model.nodes.length;
  nBeamsEl.textContent=model.beams.length;
  nCondsEl.textContent=Object.values(model.conditions||{}).flat().length;
  solveStateEl.textContent = res ? 'solved' : 'unsolved';

  if(!res) return;

  Object.entries(res.displacements).forEach(([nid,d])=>{
    const li=document.createElement('li');
    li.textContent=`Node ${nid}: ux=${d.ux.toExponential(3)}, uy=${d.uy.toExponential(3)}, uz=${d.uz.toExponential(3)}, rx=${d.rx.toExponential(3)}, ry=${d.ry.toExponential(3)}, rz=${d.rz.toExponential(3)}`;
    dispList.appendChild(li);
  });
  Object.entries(res.reactions).forEach(([nid,r])=>{
    const li=document.createElement('li');
    li.textContent=`Node ${nid}: Fx=${(r.Fx||0).toFixed(4)}, Fy=${(r.Fy||0).toFixed(4)}, Fz=${(r.Fz||0).toFixed(4)}, Mx=${(r.Mx||0).toFixed(4)}, My=${(r.My||0).toFixed(4)}, Mz=${(r.Mz||0).toFixed(4)}`;
    reactionList.appendChild(li);
  });
  Object.entries(res.beamForces).forEach(([bid,b])=>{
    const e=(model.beams||[]).find(x=>x.id===+bid);
    const li=document.createElement('li');
    li.innerHTML=`Beam ${bid}: A(N${e?.nodeA ?? '?'}) Fx=${b.endA.Fx.toFixed(3)} Fy=${b.endA.Fy.toFixed(3)} Fz=${b.endA.Fz.toFixed(3)} Mx=${b.endA.Mx.toFixed(3)} My=${b.endA.My.toFixed(3)} Mz=${b.endA.Mz.toFixed(3)}<br/>
                           B(N${e?.nodeB ?? '?'}) Fx=${b.endB.Fx.toFixed(3)} Fy=${b.endB.Fy.toFixed(3)} Fz=${b.endB.Fz.toFixed(3)} Mx=${b.endB.Mx.toFixed(3)} My=${b.endB.My.toFixed(3)} Mz=${b.endB.Mz.toFixed(3)}`;
    beamForceList.appendChild(li);
  });
}

/* =========================
   Stress utilities (von Mises) + color map
   ========================= */
function sectionExtents(kind, dims){
  const k=String(kind||'').toLowerCase();
  if(k==='rect'){
    const b = dims.B ?? dims.b ?? 0;
    const h = dims.H ?? dims.h ?? 0;
    return {y: Math.abs(h)/2, z: Math.abs(b)/2};
  } else if(k==='recttube'){
    const B = dims.B ?? dims.b ?? 0;
    const H = dims.H ?? dims.h ?? 0;
    return {y: Math.abs(H)/2, z: Math.abs(B)/2};
  } else if(k==='ibeam' || k==='i-beam' || k==='wideflange'){
    const Bf=dims.Bf ?? dims.bf ?? 0; const H=dims.H ?? dims.h ?? 0;
    return {y: Math.abs(H)/2, z: Math.abs(Bf)/2};
  } else { // circle/tube
    const D = dims.D ?? dims.d ?? 0; const r=Math.abs(D)/2; return {y:r, z:r};
  }
}
function vonMisesFromLocal(N,Vy,Vz,T,My,Mz, xsec){
  const A=xsec.A, Iy=xsec.Iy, Iz=xsec.Iz, J=xsec.J;
  if(!(isFinite(A)&&isFinite(Iy)&&isFinite(Iz)&&isFinite(J))) return NaN;
  const ext=sectionExtents(xsec.kind, xsec.dims||{});
  const y=ext.y||0, z=ext.z||0;
  // Evaluate extreme normal stress at four corners; take max magnitude
  function sigmaAt(yy,zz){ return (N/A) + (Mz*yy/Iz) - (My*zz/Iy); }
  const s1=Math.abs(sigmaAt(+y,+z));
  const s2=Math.abs(sigmaAt(+y,-z));
  const s3=Math.abs(sigmaAt(-y,+z));
  const s4=Math.abs(sigmaAt(-y,-z));
  const sigma = Math.max(s1,s2,s3,s4);
  // Torsion shear approx at outer radius
  const r_t = Math.hypot(y,z) || 0;
  const tau_t = Math.abs(T) * (r_t/(J||1));
  // Shear due to V (simple average estimate)
  const tau_v = Math.hypot(Vy,Vz) / (A||1);
  const tau = Math.hypot(tau_t, tau_v);
  return Math.sqrt(sigma*sigma + 3*tau*tau);
}
function computeStressStats(model, res){
  if(!res) return null;
  const bfL = res.beamForcesLocal||{};
  let mn=Infinity,mx=-Infinity, any=false;
  // Determine yield limit from used materials (min Sy across beams)
  let syMin=Infinity;
  (model.beams||[]).forEach(b=>{
    const mname=b.material; const mat = mname? (materialsLib||{})[mname] : null;
    const sy = mat?.sy;
    if(isFinite(sy) && sy>0 && sy<syMin) syMin=sy;
  });
  for(const b of model.beams||[]){
    if(b.type==='spring' || b.type==='rigidlink') continue;
    if(!(b.xsec && b.xsec.kind)) continue;
    const lf=bfL[b.id]; if(!lf) continue;
    const A=b.A, Iy=b.Iy, Iz=b.Iz, J=b.J;
    const xsecInfo={A,Iy,Iz,J,kind:b.xsec.kind,dims:b.xsec.dims||{}};
    const Aend=lf.endA, Bend=lf.endB;
    const S=16;
    for(let i=0;i<=S;i++){
      const t=i/S;
      // For prismatic members with no distributed loads: N, V, T are constant.
      const N = (Aend.Fx - Bend.Fx)/2;   // equals Aend.Fx when Bend.Fx = -Aend.Fx
      const Vy= (Aend.Fy - Bend.Fy)/2;
      const Vz= (Aend.Fz - Bend.Fz)/2;
      const T = (Aend.Mx - Bend.Mx)/2;
      // Bending moments vary linearly; flip B-end sign to align internal convention along the span
      const My= (1-t)*Aend.My + t*(-Bend.My);
      const Mz= (1-t)*Aend.Mz + t*(-Bend.Mz);
      const vm = vonMisesFromLocal(N,Vy,Vz,T,My,Mz,xsecInfo);
      if(isFinite(vm)){ any=true; if(vm<mn) mn=vm; if(vm>mx) mx=vm; }
    }
  }
  let maxUse = mx;
  if(isFinite(syMin) && syMin>0) maxUse = syMin;
  return any ? {min:0, max:maxUse} : null;
}
function lerp(a,b,t){ return a + (b-a)*t; }
function colorMap01(t){
  // 6-point gradient: blue -> cyan -> green -> yellow -> orange -> red
  const stops=[
    {c:[59,130,246]},   // blue #3b82f6
    {c:[6,182,212]},    // cyan #06b6d4
    {c:[34,197,94]},    // green #22c55e
    {c:[250,204,21]},   // yellow #facc15
    {c:[251,146,60]},   // orange #fb923c
    {c:[239,68,68]},    // red #ef4444
  ];
  const n = stops.length - 1;
  const u = Math.max(0, Math.min(1, t));
  if (u >= 1) { const c = stops[n].c; return `rgb(${c[0]},${c[1]},${c[2]})`; }
  const x = u * n;
  const i = Math.floor(x);
  const f = x - i;
  const a = stops[i].c, b = stops[i+1].c;
  const r = Math.round(lerp(a[0],b[0],f)), g = Math.round(lerp(a[1],b[1],f)), bl = Math.round(lerp(a[2],b[2],f));
  return `rgb(${r},${g},${bl})`;
}

/* =========================
   Viewer: free orbit, fixed scale, axis triad, dual shape, hinge glyphs
   ========================= */
let cam={
  // Default to isometric: x→left+down, y→right+down, z→up
  // yaw = 225°, pitch = -atan(1/sqrt(2)) ≈ -35.264°
  yaw: (225*Math.PI/180),
  pitch: -Math.atan(1/Math.SQRT2),
  zoom:1,
  baseScale:1,
  panX:0, panY:0,
  target:{x:0,y:0,z:0},
};
let showBeamGraphics = true;
let showStressMap = false;
let stressStats = null; // {min, max}

function setZoom(z){
  cam.zoom = Math.max(0.1, z);
  zoomEl.value = cam.zoom.toFixed(2);
}
function computeTarget(model){
  if(!model.nodes.length){ cam.target={x:0,y:0,z:0}; return; }
  let sx=0,sy=0,sz=0;
  model.nodes.forEach(n=>{ sx+=n.x; sy+=n.y; sz+=n.z; });
  cam.target = {x:sx/model.nodes.length, y:sy/model.nodes.length, z:sz/model.nodes.length};
}
function cameraMatrix(){
  const cy=Math.cos(cam.yaw), sy=Math.sin(cam.yaw);
  const cp=Math.cos(cam.pitch), sp=Math.sin(cam.pitch);
  const f = normalize([cp*cy, cp*sy, sp]);
  let r = cross(f, [0,0,1]);
  const rL=Math.hypot(r[0],r[1],r[2]);
  if(rL<1e-6) r=[1,0,0]; else r=[r[0]/rL, r[1]/rL, r[2]/rL];
  const u = cross(r, f);
  return [
    [ r[0],  r[1],  r[2] ],
    [ -u[0], -u[1], -u[2] ],
    [ f[0],  f[1],  f[2] ],
  ];
}

// Fit once against union of undeformed and deformed geometry
function computeFitScale(model, res){
  const ex = parseFloat(exagEl.value)||1;
  const disp = res?.displacements || {};
  const getDisp = (id,exMul) => {
    const d=disp[id]||{ux:0,uy:0,uz:0};
    return [d.ux*ex,d.uy*ex,d.uz*ex];
  };
  if(!model.nodes.length){ cam.baseScale=1; return; }

  let Rmax=0;
  [0,1].forEach(exMul=>{
    model.nodes.forEach(n=>{
      const d=getDisp(n.id,exMul);
      const x=n.x - cam.target.x + d[0];
      const y=n.y - cam.target.y + d[1];
      const z=n.z - cam.target.z + d[2];
      const r=Math.hypot(x,y,z);
      if(r>Rmax) Rmax=r;
    });
  });
  if(Rmax<1e-9) Rmax=1;

  if(animationMode && animationMode.displacements){
    model.nodes.forEach(n=>{
      const dispDyn = animationMode.displacements[n.id];
      if(!dispDyn) return;
      const ampX = (dispDyn.ux?.amp || 0)*ex;
      const ampY = (dispDyn.uy?.amp || 0)*ex;
      const ampZ = (dispDyn.uz?.amp || 0)*ex;
      const r = Math.hypot(ampX, ampY, ampZ);
      if(r>Rmax) Rmax=r;
    });
  }

  const rect=canvas.getBoundingClientRect();
  const margin=40;
  const view = Math.max(10, Math.min(rect.width, rect.height) - 2*margin);
  cam.baseScale = view / (2*Rmax);
}

// exMul = 0 -> undeformed; 1 -> use exagEl
function projectPoints(model, res, exMul=1){
  const ex = (parseFloat(exagEl.value)||1) * exMul;
  const disp = res?.displacements || {};
  const getDisp = id => {
    if(animationActive && animationMode?.displacements){
      const dyn = animationMode.displacements[id];
      if(dyn){
        const t = animationTimeSec;
        const omega = animationMode.omega || 0;
        return [
          (dyn.ux?.amp || 0)*ex*Math.cos(omega*t + (dyn.ux?.phase || 0)),
          (dyn.uy?.amp || 0)*ex*Math.cos(omega*t + (dyn.uy?.phase || 0)),
          (dyn.uz?.amp || 0)*ex*Math.cos(omega*t + (dyn.uz?.phase || 0))
        ];
      }
    }
    const d=disp[id]||{ux:0,uy:0,uz:0};
    return [d.ux*ex*exMul,d.uy*ex*exMul,d.uz*ex*exMul];
  };

  const R = cameraMatrix();

  const pts = model.nodes.map(n=>{
    const d=getDisp(n.id);
    const pw=[n.x - cam.target.x + d[0], n.y - cam.target.y + d[1], n.z - cam.target.z + d[2]];
    const x = R[0][0]*pw[0] + R[0][1]*pw[1] + R[0][2]*pw[2];
    const y = R[1][0]*pw[0] + R[1][1]*pw[1] + R[1][2]*pw[2];
    const z = R[2][0]*pw[0] + R[2][1]*pw[1] + R[2][2]*pw[2];
    return {id:n.id, x, y, z, wpos:[n.x+d[0],n.y+d[1],n.z+d[2]], wpos0:[n.x,n.y,n.z]};
  });

  return pts;
}

let currentScreenMap=null;

function render(model, res){
  const rect=canvas.getBoundingClientRect();
  const dpr=window.devicePixelRatio||1;
  canvas.width=Math.max(1, Math.floor(rect.width*dpr));
  canvas.height=Math.max(1, Math.floor(rect.height*dpr));
  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(dpr,dpr);
  ctx.clearRect(0,0,rect.width,rect.height);

  // Axis triad (3D arrows with orthographic sizing, clipped in a larger circle)
  const drawTriad = ()=>{
    const pad = 18;
    const r = 44; // circle radius
    const baseX = pad + r + 2;
    const baseY = rect.height - pad - r - 2;

    // Background circle + clip
    ctx.save();
    ctx.globalAlpha=0.12; ctx.fillStyle='#ffffff';
    ctx.beginPath(); ctx.arc(baseX, baseY, r, 0, 2*Math.PI); ctx.fill();
    ctx.globalAlpha=1.0; ctx.beginPath(); ctx.arc(baseX, baseY, r-1, 0, 2*Math.PI); ctx.clip();

    // Camera bases and projectors
    const R = cameraMatrix();
    const right = R[0];
    const upCam = [-R[1][0], -R[1][1], -R[1][2]];
    const fwd = R[2];

    // Converters
    const scalePxPerWorld = (cam.baseScale||1)*cam.zoom;
    const ox = rect.width/2 + cam.panX;
    const oy = rect.height/2 + cam.panY;
    function toCam(p){
      const px=p.x - cam.target.x, py=p.y - cam.target.y, pz=p.z - cam.target.z;
      return {
        x: right[0]*px + right[1]*py + right[2]*pz,
        y: -upCam[0]*px - upCam[1]*py - upCam[2]*pz,
        z: fwd[0]*px + fwd[1]*py + fwd[2]*pz,
      };
    }
    function toScreen(pc){ return {x: pc.x*scalePxPerWorld + ox, y: pc.y*scalePxPerWorld + oy, z: pc.z}; }
    function screenToWorld(x,y, zcam=0){
      const cx = (x - ox)/scalePxPerWorld, cy = (y - oy)/scalePxPerWorld;
      return {
        x: cam.target.x + right[0]*cx + (R[1][0])*cy + fwd[0]*zcam,
        y: cam.target.y + right[1]*cx + (R[1][1])*cy + fwd[1]*zcam,
        z: cam.target.z + right[2]*cx + (R[1][2])*cy + fwd[2]*zcam,
      };
    }

    // Face queue for triad
    const triadQ=[];
    function qFace(pts, z, fill, a){ triadQ.push({pts, z, fill, a}); }
    function cyl(a,b, Rloc, rad, seg, fill, alpha){
      const ey=Rloc[1], ez=Rloc[2];
      const A=[], B=[];
      for(let k=0;k<seg;k++){
        const th=2*Math.PI*k/seg; const sy=Math.sin(th)*rad, sz=Math.cos(th)*rad;
        const p1={x:a.x+ey[0]*sy+ez[0]*sz, y:a.y+ey[1]*sy+ez[1]*sz, z:a.z+ey[2]*sy+ez[2]*sz};
        const p2={x:b.x+ey[0]*sy+ez[0]*sz, y:b.y+ey[1]*sy+ez[1]*sz, z:b.z+ey[2]*sy+ez[2]*sz};
        A.push(toScreen(toCam(p1))); B.push(toScreen(toCam(p2)));
      }
      for(let k=0;k<seg;k++){
        const k2=(k+1)%seg; const f=[A[k],A[k2],B[k2],B[k]]; const z=(f[0].z+f[1].z+f[2].z+f[3].z)/4;
        qFace(f.map(p=>({x:p.x,y:p.y})), z, fill, alpha);
      }
    }
    function cone(bas, tip, Rloc, rad, seg, fill, alpha){
      const ey=Rloc[1], ez=Rloc[2]; const apex=toScreen(toCam(tip)); const ring=[];
      for(let k=0;k<seg;k++){
        const th=2*Math.PI*k/seg; const sy=Math.sin(th)*rad, sz=Math.cos(th)*rad;
        const p={x:bas.x+ey[0]*sy+ez[0]*sz, y:bas.y+ey[1]*sy+ez[1]*sz, z:bas.z+ey[2]*sy+ez[2]*sz};
        ring.push(toScreen(toCam(p)));
      }
      for(let k=0;k<seg;k++){
        const k2=(k+1)%seg; const a=ring[k], b=ring[k2], c=apex; const z=(a.z+b.z+c.z)/3;
        qFace([{x:a.x,y:a.y},{x:b.x,y:b.y},{x:c.x,y:c.y}], z, fill, alpha);
      }
    }

    const baseW = screenToWorld(baseX, baseY, 0);
    // One more step longer
    const headPx=10, labelOffPx=4, marginPx=2;
    const Lpx = Math.max(0, r - headPx - labelOffPx - marginPx);
    const rSpx = 2.2, rHpx=3.6; // fixed pixel radii

    function drawAxis(dir, color, lab){
      // Mimic force vectors: keep size orthographic (no dependence on projection length)
      const dirCam = { x: right[0]*dir[0] + right[1]*dir[1] + right[2]*dir[2],
                       y: -upCam[0]*dir[0] - upCam[1]*dir[1] - upCam[2]*dir[2] };
      const Lw = Lpx / scalePxPerWorld;
      const headLw = headPx/scalePxPerWorld; const shaftLw=Math.max(0,Lw-headLw);
      const tip={x:baseW.x+dir[0]*Lw, y:baseW.y+dir[1]*Lw, z:baseW.z+dir[2]*Lw};
      const mid={x:baseW.x+dir[0]*shaftLw, y:baseW.y+dir[1]*shaftLw, z:baseW.z+dir[2]*shaftLw};
      // Stable upHint: prefer camera up; if nearly parallel, use camera right
      const dotUp = dir[0]*upCam[0] + dir[1]*upCam[1] + dir[2]*upCam[2];
      const upHint = Math.abs(dotUp)>0.95 ? right : upCam;
      const Rloc = beamRotation(baseW, tip, upHint);
      // Constant pixel radii converted to world units
      const rS = rSpx/scalePxPerWorld, rH = rHpx/scalePxPerWorld;
      cyl(baseW, mid, Rloc, rS, 12, color, 0.95);
      cone(mid, tip, Rloc, rH, 12, color, 0.95);
      // Label near tip in projected direction
      const tipS=toScreen(toCam(tip)); const ang=Math.atan2(dirCam.y, dirCam.x);
      ctx.fillStyle='#cbd5dc'; ctx.font='11px ui-monospace,Consolas,monospace';
      ctx.fillText(lab, tipS.x + (labelOffPx-2)*Math.cos(ang), tipS.y + (labelOffPx-2)*Math.sin(ang));
    }

    drawAxis([1,0,0], '#ff5a5a', 'x');
    drawAxis([0,1,0], '#5ad15a', 'y');
    drawAxis([0,0,1], '#4e8cff', 'z');

    // Flush triad
    triadQ.sort((a,b)=> b.z - a.z);
    triadQ.forEach(f=>{ ctx.save(); ctx.globalAlpha=f.a; ctx.fillStyle=f.fill; ctx.beginPath(); f.pts.forEach((p,i)=>{ if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); }); ctx.closePath(); ctx.fill(); ctx.restore(); });

    ctx.restore();
  };

  if(model.nodes.length===0){
    currentScreenMap=null;
    drawTriad();
    return;
  }

  const scale = (cam.baseScale || 1) * cam.zoom;
  const ox = rect.width/2 + cam.panX;
  const oy = rect.height/2 + cam.panY;

  let Pdef, Pbase;
  if(res){
    Pbase = projectPoints(model,res,0);
    Pdef  = projectPoints(model,res,1);
  }else{
    Pbase = projectPoints(model,null,0);
    Pdef  = null;
  }

  const mapById = arr => { const o={}; arr.forEach(p=>o[p.id]=p); return o; };
  const Pb = mapById(Pbase);
  const Pd = Pdef ? mapById(Pdef) : null;

  // (moved) Wireframe overlay drawn later so it always shows in both states

  // deformed
  if(Pd){
    // Helper: robust 3D face drawing with painter's sort
    const Rcam = cameraMatrix();
    const target = cam.target;
    function toCam(p){
      const px = p.x - target.x, py = p.y - target.y, pz = p.z - target.z;
      return {
        x: Rcam[0][0]*px + Rcam[0][1]*py + Rcam[0][2]*pz,
        y: Rcam[1][0]*px + Rcam[1][1]*py + Rcam[1][2]*pz,
        z: Rcam[2][0]*px + Rcam[2][1]*py + Rcam[2][2]*pz,
      };
    }
    function toScreen(pc){ return {x: pc.x*scale+ox, y: pc.y*scale+oy, z: pc.z}; }
    const faceQ=[];
    function queueFace(pts2d, zAvg, fill='#2a9df4', alpha=0.22){
      faceQ.push({pts:pts2d, z:zAvg, fill, alpha});
    }
    function queueAxisAlignedBox(center, sx, sy, sz, fill=MASS_BOX_COLOR, alpha=MASS_BOX_ALPHA){
      if(!(isFinite(sx)&&isFinite(sy)&&isFinite(sz))) return;
      const hx=sx*0.5, hy=sy*0.5, hz=sz*0.5;
      if(hx<=0 || hy<=0 || hz<=0) return;
      const verts=[
        {x:center.x - hx, y:center.y - hy, z:center.z - hz},
        {x:center.x + hx, y:center.y - hy, z:center.z - hz},
        {x:center.x + hx, y:center.y + hy, z:center.z - hz},
        {x:center.x - hx, y:center.y + hy, z:center.z - hz},
        {x:center.x - hx, y:center.y - hy, z:center.z + hz},
        {x:center.x + hx, y:center.y - hy, z:center.z + hz},
        {x:center.x + hx, y:center.y + hy, z:center.z + hz},
        {x:center.x - hx, y:center.y + hy, z:center.z + hz},
      ].map(p=>toScreen(toCam(p)));
      const faces=[
        [0,1,2,3],[4,5,6,7],
        [0,1,5,4],[1,2,6,5],
        [2,3,7,6],[3,0,4,7],
      ];
      faces.forEach(idx=>{
        const pts2=idx.map(k=>({x:verts[k].x,y:verts[k].y}));
        const zAvg=idx.reduce((sum,k)=>sum+verts[k].z,0)/idx.length;
        queueFace(pts2, zAvg, fill, alpha);
      });
    }
    function addMassBoxes(){
      if(!nodeMasses) return;
      Object.entries(nodeMasses).forEach(([nid, mass])=>{
        if(!mass) return;
        const w=Number(mass.width)||0;
        const l=Number(mass.length)||0;
        const h=Number(mass.height)||0;
        if(!(w>0 && l>0 && h>0)) return;
        const pt = Pd[nid] || Pb[nid];
        if(!pt || !pt.wpos) return;
        const center={x:pt.wpos[0], y:pt.wpos[1], z:pt.wpos[2]};
        queueAxisAlignedBox(center, w, l, h);
      });
    }
    function drawBox3D(na, nb, Rloc, H, B, fillColor='#2a9df4', alpha=0.22){
      const hy=H*0.5, hz=B*0.5;
      const ey=Rloc[1], ez=Rloc[2];
      function add(a, sY, sZ){
        return { x: a.x + ey[0]*sY + ez[0]*sZ,
                 y: a.y + ey[1]*sY + ez[1]*sZ,
                 z: a.z + ey[2]*sY + ez[2]*sZ };
      }
      const A1=add(na, +hy, +hz), A2=add(na, +hy, -hz), A3=add(na, -hy, -hz), A4=add(na, -hy, +hz);
      const B1=add(nb, +hy, +hz), B2=add(nb, +hy, -hz), B3=add(nb, -hy, -hz), B4=add(nb, -hy, +hz);
      const verts = [A1,A2,A3,A4,B1,B2,B3,B4].map(p=>toScreen(toCam(p)));
      const faces=[
        [0,1,2,3], // cap A
        [4,5,6,7], // cap B
        [0,4,5,1], // side 1
        [1,5,6,2], // side 2
        [2,6,7,3], // side 3
        [3,7,4,0], // side 4
      ];
      // painter's sort by depth (farther first)
      faces.forEach(idxs=>{
        const zAvg = idxs.reduce((s,k)=>s+verts[k].z,0)/idxs.length;
        const pts2 = idxs.map(k=>({x:verts[k].x,y:verts[k].y}));
        queueFace(pts2, zAvg, fillColor, alpha);
      });
    }
    function drawCylinder3D(na, nb, Rloc, radius, segments=20, fillColor='#2a9df4', alpha=0.18){
      const ey=Rloc[1], ez=Rloc[2];
      const ringA=[], ringB=[];
      for(let k=0;k<segments;k++){
        const th=2*Math.PI*k/segments; const sy=Math.sin(th)*radius, sz=Math.cos(th)*radius;
        const a = { x: na.x + ey[0]*sy + ez[0]*sz,
                    y: na.y + ey[1]*sy + ez[1]*sz,
                    z: na.z + ey[2]*sy + ez[2]*sz };
        const b = { x: nb.x + ey[0]*sy + ez[0]*sz,
                    y: nb.y + ey[1]*sy + ez[1]*sz,
                    z: nb.z + ey[2]*sy + ez[2]*sz };
        ringA.push(toScreen(toCam(a)));
        ringB.push(toScreen(toCam(b)));
      }
      const faces=[];
      for(let k=0;k<segments;k++){
        const k2=(k+1)%segments;
        const face=[ {x:ringA[k].x,y:ringA[k].y,z:ringA[k].z},
                     {x:ringA[k2].x,y:ringA[k2].y,z:ringA[k2].z},
                     {x:ringB[k2].x,y:ringB[k2].y,z:ringB[k2].z},
                     {x:ringB[k].x,y:ringB[k].y,z:ringB[k].z} ];
        const zavg=(face[0].z+face[1].z+face[2].z+face[3].z)/4;
        faces.push({face, z:zavg});
      }
      faces.forEach(f=> queueFace(f.face.map(p=>({x:p.x,y:p.y})), f.z, fillColor, alpha));
    }

    ctx.strokeStyle='#4cc9f0'; ctx.lineWidth=2;
    model.beams.forEach(b=>{
      const a=Pd[b.nodeA], c=Pd[b.nodeB]; if(!a||!c) return;
      if(showBeamGraphics && b.xsec && b.xsec.kind){
        const na={x:a.wpos[0], y:a.wpos[1], z:a.wpos[2]};
        const nb={x:c.wpos[0], y:c.wpos[1], z:c.wpos[2]};
        const Rloc = beamRotation(na, nb, b.up);
        const kind = String(b.xsec.kind).toLowerCase();
        const useStress = showStressMap && results && (results.beamForcesLocal?.[b.id]);
        if(useStress && stressStats && isFinite(stressStats.min) && isFinite(stressStats.max) && stressStats.max>stressStats.min){
          // segment the beam
          const lf = results.beamForcesLocal[b.id];
          const Aend=lf.endA, Bend=lf.endB;
          const A=b.A, Iy=b.Iy, Iz=b.Iz, J=b.J;
          const xsecInfo={A,Iy,Iz,J,kind:b.xsec.kind,dims:b.xsec.dims||{}};
          const S=18;
          for(let i=0;i<S;i++){
            const t0=i/S, t1=(i+1)/S;
            const p0={x:na.x + (nb.x-na.x)*t0, y:na.y + (nb.y-na.y)*t0, z:na.z + (nb.z-na.z)*t0};
            const p1={x:na.x + (nb.x-na.x)*t1, y:na.y + (nb.y-na.y)*t1, z:na.z + (nb.z-na.z)*t1};
            // Use constant N,V,T and linear bending moments
            const N = (Aend.Fx - Bend.Fx)/2;
            const Vy= (Aend.Fy - Bend.Fy)/2;
            const Vz= (Aend.Fz - Bend.Fz)/2;
            const T = (Aend.Mx - Bend.Mx)/2;
            const tm = (i+0.5)/S;
            const My= (1-tm)*Aend.My + tm*(-Bend.My);
            const Mz= (1-tm)*Aend.Mz + tm*(-Bend.Mz);
            const vm = vonMisesFromLocal(N,Vy,Vz,T,My,Mz, xsecInfo);
            const tcol = (stressStats && stressStats.max>0) ? (vm / stressStats.max) : 0;
            const col = colorMap01(tcol);
            if(kind==='rect' || kind==='recttube'){
              const B = (b.xsec.dims.B ?? b.xsec.dims.b) || 0;
              const H = (b.xsec.dims.H ?? b.xsec.dims.h) || 0;
              drawBox3D(p0, p1, Rloc, H, B, col, 0.6);
            } else if(kind==='ibeam' || kind==='i-beam' || kind==='wideflange'){
              const Bf=b.xsec.dims.Bf||b.xsec.dims.bf||0;
              const H=b.xsec.dims.H||b.xsec.dims.h||0;
              const tf=b.xsec.dims.tf||0;
              const tw=b.xsec.dims.tw||0;
              const hw = Math.max(0, H - 2*tf);
              const off = (H/2 - tf/2);
              // top flange
              const top0 = {x:p0.x + Rloc[1][0]*off, y:p0.y + Rloc[1][1]*off, z:p0.z + Rloc[1][2]*off};
              const top1 = {x:p1.x + Rloc[1][0]*off, y:p1.y + Rloc[1][1]*off, z:p1.z + Rloc[1][2]*off};
              drawBox3D(top0, top1, Rloc, tf, Bf, col, 0.6);
              // bottom flange
              const bot0 = {x:p0.x - Rloc[1][0]*off, y:p0.y - Rloc[1][1]*off, z:p0.z - Rloc[1][2]*off};
              const bot1 = {x:p1.x - Rloc[1][0]*off, y:p1.y - Rloc[1][1]*off, z:p1.z - Rloc[1][2]*off};
              drawBox3D(bot0, bot1, Rloc, tf, Bf, col, 0.6);
              // web
              drawBox3D(p0, p1, Rloc, hw, tw, col, 0.6);
            } else { // round
              const D = (b.xsec.dims.D || b.xsec.dims.d || 0);
              const rad = Math.max(0, D*0.5);
              drawCylinder3D(p0, p1, Rloc, rad, 18, col, 0.6);
            }
          }
        } else {
          // no stress overlay
          if(kind==='rect' || kind==='recttube'){
            const B = (b.xsec.dims.B ?? b.xsec.dims.b) || 0;
            const H = (b.xsec.dims.H ?? b.xsec.dims.h) || 0;
            drawBox3D(na, nb, Rloc, H, B);
          } else if(kind==='ibeam' || kind==='i-beam' || kind==='wideflange'){
            const Bf=b.xsec.dims.Bf||b.xsec.dims.bf||0;
            const H=b.xsec.dims.H||b.xsec.dims.h||0;
            const tf=b.xsec.dims.tf||0;
            const tw=b.xsec.dims.tw||0;
            const hw = Math.max(0, H - 2*tf);
            const off = (H/2 - tf/2);
            // top flange
            const topA = {x:na.x + Rloc[1][0]*off, y:na.y + Rloc[1][1]*off, z:na.z + Rloc[1][2]*off};
            const topB = {x:nb.x + Rloc[1][0]*off, y:nb.y + Rloc[1][1]*off, z:nb.z + Rloc[1][2]*off};
            drawBox3D(topA, topB, Rloc, tf, Bf);
            // bottom flange
            const botA = {x:na.x - Rloc[1][0]*off, y:na.y - Rloc[1][1]*off, z:na.z - Rloc[1][2]*off};
            const botB = {x:nb.x - Rloc[1][0]*off, y:nb.y - Rloc[1][1]*off, z:nb.z - Rloc[1][2]*off};
            drawBox3D(botA, botB, Rloc, tf, Bf);
            // web
            drawBox3D(na, nb, Rloc, hw, tw);
          } else if(kind==='circ' || kind==='circle' || kind==='tube' || kind==='pipe' || kind==='hollow'){
            const D = (b.xsec.dims.D || b.xsec.dims.d || 0);
            const rad = Math.max(0, D*0.5);
            drawCylinder3D(na, nb, Rloc, rad, 20);
          } else {
            // Fallback thin line
            ctx.beginPath(); ctx.moveTo(a.x*scale+ox,a.y*scale+oy); ctx.lineTo(c.x*scale+ox,c.y*scale+oy); ctx.stroke();
          }
        }
      } else {
        // Legacy beam: thin line
        if(!showBeamGraphics){ ctx.beginPath(); ctx.moveTo(a.x*scale+ox,a.y*scale+oy); ctx.lineTo(c.x*scale+ox,c.y*scale+oy); ctx.stroke(); }
      }
    });
    addMassBoxes();

    // Flush faces: global depth sort (far → near)
    faceQ.sort((a,b)=> b.z - a.z);
    faceQ.forEach(f=>{
      ctx.save();
      ctx.globalAlpha = f.alpha;
      ctx.fillStyle = f.fill;
      ctx.beginPath();
      f.pts.forEach((p,i)=>{ if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); });
      ctx.closePath(); ctx.fill();
      ctx.globalAlpha = Math.min(0.8, f.alpha*2.5);
      ctx.strokeStyle = '#1e293b'; ctx.lineWidth=1.0; ctx.stroke();
      ctx.restore();
    });

    // Always overlay undeformed wireframe (dashed)
    ctx.save();
    ctx.strokeStyle='#3a4550'; ctx.lineWidth=1.5; ctx.setLineDash([6,5]);
    model.beams.forEach(b=>{ const a=Pb[b.nodeA], c=Pb[b.nodeB]; if(!a||!c) return; ctx.beginPath(); ctx.moveTo(a.x*scale+ox, a.y*scale+oy); ctx.lineTo(c.x*scale+ox, c.y*scale+oy); ctx.stroke(); });
    ctx.setLineDash([]);
    ctx.fillStyle='transparent'; ctx.strokeStyle='#637180'; ctx.lineWidth=1.2;
    model.nodes.forEach(n=>{ const p=Pb[n.id]; const px=p.x*scale+ox, py=p.y*scale+oy; ctx.beginPath(); ctx.arc(px,py,4,0,2*Math.PI); ctx.stroke(); });
    ctx.restore();

    // Always overlay deformed centerlines (even when beam graphics are shown)
    if(showBeamGraphics){
      ctx.save();
      ctx.strokeStyle='#4cc9f0'; ctx.lineWidth=2; ctx.setLineDash([]); ctx.globalAlpha=0.9;
      model.beams.forEach(b=>{
        const a=Pd[b.nodeA], c=Pd[b.nodeB]; if(!a||!c) return;
        ctx.beginPath(); ctx.moveTo(a.x*scale+ox, a.y*scale+oy); ctx.lineTo(c.x*scale+ox, c.y*scale+oy); ctx.stroke();
      });
      ctx.restore();
    }

    ctx.fillStyle='#80ed99';
    model.nodes.forEach(n=>{
      const p=Pd[n.id]; const px=p.x*scale+ox, py=p.y*scale+oy;
      ctx.beginPath(); ctx.arc(px,py,4,0,2*Math.PI); ctx.fill();
      ctx.fillStyle='#cbd5dc'; ctx.font='12px ui-monospace,Consolas,monospace';
      ctx.fillText(n.id, px+6, py-6);
      ctx.fillStyle='#80ed99';
    });
  }else{
    ctx.fillStyle='#cbd5dc'; ctx.font='12px ui-monospace,Consolas,monospace';
    model.nodes.forEach(n=>{
      const p=Pb[n.id]; const px=p.x*scale+ox, py=p.y*scale+oy;
      ctx.fillText(n.id, px+6, py-6);
    });
    const Rcam = cameraMatrix();
    function toCam(p){
      const px = p.x - cam.target.x, py = p.y - cam.target.y, pz = p.z - cam.target.z;
      return {
        x: Rcam[0][0]*px + Rcam[0][1]*py + Rcam[0][2]*pz,
        y: Rcam[1][0]*px + Rcam[1][1]*py + Rcam[1][2]*pz,
        z: Rcam[2][0]*px + Rcam[2][1]*py + Rcam[2][2]*pz,
      };
    }
    function toScreen(pc){ return {x: pc.x*scale+ox, y: pc.y*scale+oy, z: pc.z}; }
    const faceQ0=[];
    function queueFace0(pts2d, zAvg, fill='#2a9df4', alpha=0.22){ faceQ0.push({pts:pts2d, z:zAvg, fill, alpha}); }
    function queueAxisAlignedBox0(center, sx, sy, sz, fill=MASS_BOX_COLOR, alpha=MASS_BOX_ALPHA){
      if(!(isFinite(sx)&&isFinite(sy)&&isFinite(sz))) return;
      const hx=sx*0.5, hy=sy*0.5, hz=sz*0.5;
      if(hx<=0 || hy<=0 || hz<=0) return;
      const verts=[
        {x:center.x - hx, y:center.y - hy, z:center.z - hz},
        {x:center.x + hx, y:center.y - hy, z:center.z - hz},
        {x:center.x + hx, y:center.y + hy, z:center.z - hz},
        {x:center.x - hx, y:center.y + hy, z:center.z - hz},
        {x:center.x - hx, y:center.y - hy, z:center.z + hz},
        {x:center.x + hx, y:center.y - hy, z:center.z + hz},
        {x:center.x + hx, y:center.y + hy, z:center.z + hz},
        {x:center.x - hx, y:center.y + hy, z:center.z + hz},
      ].map(p=>toScreen(toCam(p)));
      const faces=[
        [0,1,2,3],[4,5,6,7],
        [0,1,5,4],[1,2,6,5],
        [2,3,7,6],[3,0,4,7],
      ];
      faces.forEach(idx=>{
        const pts2=idx.map(k=>({x:verts[k].x,y:verts[k].y}));
        const zAvg=idx.reduce((sum,k)=>sum+verts[k].z,0)/idx.length;
        queueFace0(pts2, zAvg, fill, alpha);
      });
    }
    function drawBox3D(na, nb, Rloc, H, B){
      const hy=H*0.5, hz=B*0.5; const ey=Rloc[1], ez=Rloc[2];
      function add(a, sY, sZ){ return { x: a.x + ey[0]*sY + ez[0]*sZ, y: a.y + ey[1]*sY + ez[1]*sZ, z: a.z + ey[2]*sY + ez[2]*sZ }; }
      const A1=add(na, +hy, +hz), A2=add(na, +hy, -hz), A3=add(na, -hy, -hz), A4=add(na, -hy, +hz);
      const B1=add(nb, +hy, +hz), B2=add(nb, +hy, -hz), B3=add(nb, -hy, -hz), B4=add(nb, -hy, +hz);
      const verts = [A1,A2,A3,A4,B1,B2,B3,B4].map(p=>toScreen(toCam(p)));
      const faces=[[0,1,2,3],[4,5,6,7],[0,4,5,1],[1,5,6,2],[2,6,7,3],[3,7,4,0]];
      faces.forEach(idxs=>{
        const zAvg = idxs.reduce((s,k)=>s+verts[k].z,0)/idxs.length;
        const pts2 = idxs.map(k=>({x:verts[k].x,y:verts[k].y}));
        queueFace0(pts2, zAvg, '#2a9df4', 0.22);
      });
    }
    function drawCylinder3D(na, nb, Rloc, radius, segments=20){
      const ey=Rloc[1], ez=Rloc[2]; const ringA=[], ringB=[];
      for(let k=0;k<segments;k++){
        const th=2*Math.PI*k/segments; const sy=Math.sin(th)*radius, sz=Math.cos(th)*radius;
        const a = { x: na.x + ey[0]*sy + ez[0]*sz, y: na.y + ey[1]*sy + ez[1]*sz, z: na.z + ey[2]*sy + ez[2]*sz };
        const b = { x: nb.x + ey[0]*sy + ez[0]*sz, y: nb.y + ey[1]*sy + ez[1]*sz, z: nb.z + ey[2]*sy + ez[2]*sz };
        ringA.push(toScreen(toCam(a))); ringB.push(toScreen(toCam(b)));
      }
      const faces=[]; for(let k=0;k<segments;k++){ const k2=(k+1)%segments; const face=[{x:ringA[k].x,y:ringA[k].y,z:ringA[k].z},{x:ringA[k2].x,y:ringA[k2].y,z:ringA[k2].z},{x:ringB[k2].x,y:ringB[k2].y,z:ringB[k2].z},{x:ringB[k].x,y:ringB[k].y,z:ringB[k].z}]; const zavg=(face[0].z+face[1].z+face[2].z+face[3].z)/4; faces.push({face,z:zavg}); }
      faces.forEach(f=> queueFace0(f.face.map(p=>({x:p.x,y:p.y})), f.z, '#2a9df4', 0.18));
    }
    function addMassBoxes0(){
      if(!nodeMasses) return;
      Object.entries(nodeMasses).forEach(([nid, mass])=>{
        if(!mass) return;
        const w=Number(mass.width)||0;
        const l=Number(mass.length)||0;
        const h=Number(mass.height)||0;
        if(!(w>0 && l>0 && h>0)) return;
        const pt = Pb[nid];
        if(!pt || !pt.wpos) return;
        const center={x:pt.wpos[0], y:pt.wpos[1], z:pt.wpos[2]};
        queueAxisAlignedBox0(center, w, l, h);
      });
    }
    if(showBeamGraphics){
      model.beams.forEach(b=>{
        if(!(b.xsec && b.xsec.kind)) return;
        const na={x:(Pb[b.nodeA]?.wpos0||[0,0,0])[0], y:(Pb[b.nodeA]?.wpos0||[0,0,0])[1], z:(Pb[b.nodeA]?.wpos0||[0,0,0])[2]};
        const nb={x:(Pb[b.nodeB]?.wpos0||[0,0,0])[0], y:(Pb[b.nodeB]?.wpos0||[0,0,0])[1], z:(Pb[b.nodeB]?.wpos0||[0,0,0])[2]};
        const Rloc = beamRotation(na, nb, b.up);
        const kind = String(b.xsec.kind).toLowerCase();
        if(kind==='rect' || kind==='recttube'){
          const B=(b.xsec.dims.B ?? b.xsec.dims.b) || 0; const H=(b.xsec.dims.H ?? b.xsec.dims.h) || 0; drawBox3D(na, nb, Rloc, H, B);
        } else if(kind==='ibeam' || kind==='i-beam' || kind==='wideflange'){
          const Bf=b.xsec.dims.Bf||b.xsec.dims.bf||0; const H=b.xsec.dims.H||b.xsec.dims.h||0; const tf=b.xsec.dims.tf||0; const tw=b.xsec.dims.tw||0; const hw=Math.max(0, H - 2*tf); const off=(H/2 - tf/2);
          const topA={x:na.x + Rloc[1][0]*off, y:na.y + Rloc[1][1]*off, z:na.z + Rloc[1][2]*off}; const topB={x:nb.x + Rloc[1][0]*off, y:nb.y + Rloc[1][1]*off, z:nb.z + Rloc[1][2]*off}; drawBox3D(topA, topB, Rloc, tf, Bf);
          const botA={x:na.x - Rloc[1][0]*off, y:na.y - Rloc[1][1]*off, z:na.z - Rloc[1][2]*off}; const botB={x:nb.x - Rloc[1][0]*off, y:nb.y - Rloc[1][1]*off, z:nb.z - Rloc[1][2]*off}; drawBox3D(botA, botB, Rloc, tf, Bf);
          drawBox3D(na, nb, Rloc, hw, tw);
        } else if(kind==='circ' || kind==='circle' || kind==='tube' || kind==='pipe' || kind==='hollow'){
          const D=(b.xsec.dims.D || b.xsec.dims.d || 0); const rad=Math.max(0, D*0.5); drawCylinder3D(na, nb, Rloc, rad, 20);
        }
      });
    }
    addMassBoxes0();
    if(faceQ0.length){
      faceQ0.sort((a,b)=> b.z - a.z);
      faceQ0.forEach(f=>{ ctx.save(); ctx.globalAlpha=f.alpha; ctx.fillStyle=f.fill; ctx.beginPath(); f.pts.forEach((p,i)=>{ if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); }); ctx.closePath(); ctx.fill(); ctx.globalAlpha=Math.min(0.8, f.alpha*2.5); ctx.strokeStyle='#1e293b'; ctx.lineWidth=1.0; ctx.stroke(); ctx.restore(); });
    }

    // Always overlay undeformed wireframe (dashed)
    ctx.save();
    ctx.strokeStyle='#3a4550'; ctx.lineWidth=1.5; ctx.setLineDash([6,5]);
    model.beams.forEach(b=>{ const a=Pb[b.nodeA], c=Pb[b.nodeB]; if(!a||!c) return; ctx.beginPath(); ctx.moveTo(a.x*scale+ox, a.y*scale+oy); ctx.lineTo(c.x*scale+ox, c.y*scale+oy); ctx.stroke(); });
    ctx.setLineDash([]);
    ctx.fillStyle='transparent'; ctx.strokeStyle='#637180'; ctx.lineWidth=1.2;
    model.nodes.forEach(n=>{ const p=Pb[n.id]; const px=p.x*scale+ox, py=p.y*scale+oy; ctx.beginPath(); ctx.arc(px,py,4,0,2*Math.PI); ctx.stroke(); });
    ctx.restore();
  }

  // hinge glyphs at released ends
  const glyph=(x,y)=>{ ctx.save(); ctx.strokeStyle='#c6b48a'; ctx.lineWidth=1.6; ctx.beginPath(); ctx.arc(x,y,5,0,2*Math.PI); ctx.stroke(); ctx.restore(); };
  model.beams.forEach(b=>{
    const a=Pb[b.nodeA], c=Pb[b.nodeB]; if(!a||!c) return;
    const ax=a.x*scale+ox, ay=a.y*scale+oy, bx=c.x*scale+ox, by=c.y*scale+oy;
    if(b.releaseA && (b.releaseA.rx||b.releaseA.ry||b.releaseA.rz)) glyph(ax,ay);
    if(b.releaseB && (b.releaseB.rx||b.releaseB.ry||b.releaseB.rz)) glyph(bx,by);
  });

  // supports / forces (3D)
  const Rvec = cameraMatrix();
  const Picons = Pd || Pb;
  // Arrow helpers: queue separate so arrows draw consistently
  const arrowQ=[];
  function queueArrowFace(pts2d, zAvg, fill='#ff6b6b', alpha=0.9){ arrowQ.push({pts:pts2d, z:zAvg, fill, alpha}); }
  function drawCylinderArrow(na, nb, Rloc, radius, segments=14, fill='#ff6b6b', alpha=0.9){
    const ey=Rloc[1], ez=Rloc[2];
    const ringA=[], ringB=[];
    for(let k=0;k<segments;k++){
      const th=2*Math.PI*k/segments; const sy=Math.sin(th)*radius, sz=Math.cos(th)*radius;
      const a = { x: na.x + ey[0]*sy + ez[0]*sz, y: na.y + ey[1]*sy + ez[1]*sz, z: na.z + ey[2]*sy + ez[2]*sz };
      const b = { x: nb.x + ey[0]*sy + ez[0]*sz, y: nb.y + ey[1]*sy + ez[1]*sz, z: nb.z + ey[2]*sy + ez[2]*sz };
      const as = toScreen(toCam(a)), bs = toScreen(toCam(b));
      ringA.push(as); ringB.push(bs);
    }
    for(let k=0;k<segments;k++){
      const k2=(k+1)%segments;
      const face=[ ringA[k], ringA[k2], ringB[k2], ringB[k] ];
      const zAvg=(face[0].z+face[1].z+face[2].z+face[3].z)/4;
      queueArrowFace(face.map(p=>({x:p.x,y:p.y})), zAvg, fill, alpha);
    }
  }
  function drawConeArrow(base, tip, Rloc, radius, segments=14, fill='#ff6b6b', alpha=0.9){
    const ey=Rloc[1], ez=Rloc[2];
    const apexS = toScreen(toCam(tip));
    const ring=[];
    for(let k=0;k<segments;k++){
      const th=2*Math.PI*k/segments; const sy=Math.sin(th)*radius, sz=Math.cos(th)*radius;
      const p = { x: base.x + ey[0]*sy + ez[0]*sz, y: base.y + ey[1]*sy + ez[1]*sz, z: base.z + ey[2]*sy + ez[2]*sz };
      ring.push(toScreen(toCam(p)));
    }
    for(let k=0;k<segments;k++){
      const k2=(k+1)%segments;
      const a=ring[k], b=ring[k2], c=apexS;
      const zAvg=(a.z+b.z+c.z)/3;
      queueArrowFace([{x:a.x,y:a.y},{x:b.x,y:b.y},{x:c.x,y:c.y}], zAvg, fill, alpha);
    }
  }

  model.nodes.forEach(n=>{
    const p=Picons[n.id]; const px=p.x*scale+ox, py=p.y*scale+oy; // still used for supports icons
    const conds=(model.conditions[n.id]||[]);
    conds.forEach(c=>{
      ctx.strokeStyle='#aaa'; ctx.lineWidth=1;
      if(c.type==='fixed'){
        ctx.beginPath(); ctx.moveTo(px-6,py+6); ctx.lineTo(px+6,py+18);
        ctx.moveTo(px-6,py+18); ctx.lineTo(px+6,py+6); ctx.stroke();
      }else if(c.type==='pinned'){
        ctx.beginPath(); ctx.moveTo(px-6,py+6); ctx.lineTo(px+6,py+6); ctx.lineTo(px,py+16); ctx.closePath(); ctx.stroke();
      }else if(c.type==='slider'){
        ctx.beginPath(); ctx.moveTo(px-8,py+10); ctx.lineTo(px+8,py+10); ctx.stroke();
      }else if(c.type==='force'){
        const fx=c.fx||0, fy=c.fy||0, fz=c.fz||0;
        const mag3=Math.hypot(fx,fy,fz);
        if(mag3<=0) return;
        const dir=[fx/mag3, fy/mag3, fz/mag3];
        // target length in pixels then convert to world units
        const Lpx = Math.max(26, Math.min(110, 22 + 12*Math.log10(1+mag3)));
        const Lw = Lpx/scale;
        const headL = Math.max(0.24*Lw, 6/scale);
        const shaftL = Math.max(0, Lw - headL);
        const base = {x:p.wpos[0], y:p.wpos[1], z:p.wpos[2]};
        const mid  = {x: base.x + dir[0]*shaftL, y: base.y + dir[1]*shaftL, z: base.z + dir[2]*shaftL};
        const tip  = {x: base.x + dir[0]*Lw,     y: base.y + dir[1]*Lw,     z: base.z + dir[2]*Lw    };
        // Build local frame for arrow along dir
        const up=[0,0,1]; const almostCol=Math.abs(dir[0]*up[0]+dir[1]*up[1]+dir[2]*up[2])>0.98; const up2=almostCol?[0,1,0]:up;
        const Rloc = beamRotation(base, tip, up2);
        // Radii in world units with pixel lower bounds
        const rShaft = Math.max(1.6/scale, Lw*0.03);
        const rHead  = Math.max(2.8/scale, rShaft*2.0);
        drawCylinderArrow(base, mid, Rloc, rShaft, 14, '#ff6b6b', 0.9);
        drawConeArrow(mid, tip, Rloc, rHead, 14, '#ff6b6b', 0.9);
      }
    });
  });
  // Flush arrow faces after queuing
  if(arrowQ.length){ arrowQ.sort((a,b)=> b.z - a.z); arrowQ.forEach(f=>{ ctx.save(); ctx.globalAlpha=f.alpha; ctx.fillStyle=f.fill; ctx.beginPath(); f.pts.forEach((p,i)=>{ if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); }); ctx.closePath(); ctx.fill(); ctx.restore(); }); }

  currentScreenMap={scale,ox,oy,pts:Pd||Pb, ptsBase:Pb};
  drawTriad();

  // legend
  ctx.save();
  ctx.font='12px ui-monospace,Consolas,monospace';
  ctx.textBaseline='middle';
  const x0 = rect.width-200, y0=18; const rowH=22; let ycur = y0;
  // Node entry (always shown)
  let cy = ycur + rowH/2;
  ctx.fillStyle='#80ed99';
  ctx.beginPath(); ctx.arc(x0+8, cy, 5, 0, 2*Math.PI); ctx.fill();
  ctx.strokeStyle='#1e293b'; ctx.lineWidth=1; ctx.stroke();
  ctx.fillStyle='#cbd5dc'; ctx.fillText('node', x0+34, cy);
  ycur += rowH; cy = ycur + rowH/2;
  // Always show wireframe legend
  ctx.strokeStyle='#3a4550'; ctx.lineWidth=1.5; ctx.setLineDash([6,5]);
  ctx.beginPath(); ctx.moveTo(x0, cy); ctx.lineTo(x0+28, cy); ctx.stroke(); ctx.setLineDash([]);
  ctx.fillStyle='#cbd5dc'; ctx.fillText('wireframe', x0+34, cy);
  ycur += rowH; cy = ycur + rowH/2;
  if(res){
    ctx.strokeStyle='#4cc9f0'; ctx.lineWidth=2; ctx.setLineDash([]);
    ctx.beginPath(); ctx.moveTo(x0, cy); ctx.lineTo(x0+28, cy); ctx.stroke();
    ctx.fillStyle='#cbd5dc'; ctx.fillText('deformed', x0+34, cy);
    ycur += rowH; cy = ycur + rowH/2;
  }
  if(showBeamGraphics){
    // Draw a filled face patch to represent beam solids (centered in row)
    const w=28, h=10;
    ctx.setLineDash([]);
    ctx.fillStyle='#2a9df4';
    ctx.globalAlpha=0.7;
    ctx.fillRect(x0, cy - h/2, w, h);
    ctx.globalAlpha=1.0;
    ctx.strokeStyle='#1e293b'; ctx.lineWidth=1;
    ctx.strokeRect(x0-0.5, cy - h/2 - 0.5, w+1, h+1);
    ctx.fillStyle='#cbd5dc';
    ctx.fillText(res ? 'beams (deformed)' : 'beams (undeformed)', x0+34, cy);
    ycur += rowH; cy = ycur + rowH/2;
  }
  ctx.textBaseline='alphabetic';
  ctx.restore();

  // Stress colorbar
  if(showBeamGraphics && showStressMap && results && stressStats && isFinite(stressStats.max) && stressStats.max>0){
    const barW = 16;
    const pad = 16;
    const barH = Math.max(220, Math.floor(rect.height * 0.7));
    const x = rect.width - barW - pad;
    // Shift down so the bottom aligns closer to the bottom of the view
    const y = rect.height - barH - pad;
    const n=96;
    for(let i=0;i<n;i++){
      const t=i/(n-1);
      ctx.fillStyle=colorMap01(1-t);
      const yy = y + Math.floor(i*(barH/(n-1)));
      const hh = Math.ceil(barH/(n-1))+1;
      ctx.fillRect(x, yy, barW, hh);
    }
    ctx.strokeStyle='#1f2937'; ctx.lineWidth=1; ctx.strokeRect(x-0.5,y-0.5,barW+1,barH+1);
    // Ticks and labels in MPa
    ctx.fillStyle='#cbd5dc'; ctx.font='11px ui-monospace,Consolas,monospace';
    const fmtMPa=(v)=>{
      const mp=v/1e6; // Pa -> MPa
      if(!isFinite(mp)) return '';
      if(Math.abs(mp)>=100) return mp.toFixed(0);
      if(Math.abs(mp)>=10)  return mp.toFixed(1);
      return mp.toFixed(2);
    };
    const ticks=[0,0.2,0.4,0.6,0.8,1.0];
    ticks.forEach(t=>{
      const yy = y + (1-t)*barH;
      ctx.strokeStyle='#94a3b8'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(x-6, yy); ctx.lineTo(x, yy); ctx.stroke();
      const val = t*stressStats.max;
      const label = fmtMPa(val);
      ctx.fillStyle='#cbd5dc';
      ctx.fillText(label, x - 8 - ctx.measureText(label).width, yy+4);
    });
    const title='σ_vM [MPa]';
    ctx.fillText(title, x - 6 - ctx.measureText(title).width, y - 8);
  }
}

/* =========================
   Tooltip  (FIXED)
   ========================= */
canvas.addEventListener('mousemove', (e) => {
  if (!currentScreenMap) {
    tooltip.style.display = 'none';
    return;
  }

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const { scale, ox, oy, pts, ptsBase } = currentScreenMap;

  const list = Object.values(pts || ptsBase || {});
  let hit = null, best = 1e9;

  list.forEach(p => {
    const x = p.x * scale + ox;
    const y = p.y * scale + oy;
    const d = Math.hypot(mx - x, my - y);
    if (d < 10 && d < best) {
      best = d;
      hit = p;
    }
  });

  if (hit) {
    const d = results?.displacements?.[hit.id];
    const r = results?.reactions?.[hit.id];
    const pb = ptsBase ? ptsBase[hit.id] : null;
    const pos0 = pb?.wpos0 || [0, 0, 0];

    let text = `Node ${hit.id}\norig=(${pos0[0].toFixed(3)}, ${pos0[1].toFixed(3)}, ${pos0[2].toFixed(3)})`;
    if (d) {
      text += `\ndef=(${hit.wpos[0].toFixed(3)}, ${hit.wpos[1].toFixed(3)}, ${hit.wpos[2].toFixed(3)})`;
      text += `\nux=${d.ux.toExponential(3)}  uy=${d.uy.toExponential(3)}  uz=${d.uz.toExponential(3)}`;
      text += `\nrx=${d.rx.toExponential(3)}  ry=${d.ry.toExponential(3)}  rz=${d.rz.toExponential(3)}`;
    }
    if (r) {
      text += `\nFx=${(r.Fx || 0).toExponential(3)} Fy=${(r.Fy || 0).toExponential(3)} Fz=${(r.Fz || 0).toExponential(3)}`;
      text += `\nMx=${(r.Mx || 0).toExponential(3)} My=${(r.My || 0).toExponential(3)} Mz=${(r.Mz || 0).toExponential(3)}`;
    }

    tooltip.textContent = text;
    tooltip.style.display = 'block';

    // Clamp position inside canvas
    const tw = tooltip.offsetWidth || 0;
    const th = tooltip.offsetHeight || 0;
    const pad = 8;
    const tx = Math.min(mx + 12, rect.width - tw - pad);
    const ty = Math.min(my + 12, rect.height - th - pad);

    tooltip.style.left = tx + 'px';
    tooltip.style.top = ty + 'px';
  } else {
    tooltip.style.display = 'none';
  }
});

canvas.addEventListener('mouseleave', ()=>tooltip.style.display='none');

/* =========================
   Camera controls
   ========================= */
let drag=false, lastX=0,lastY=0, dragMode='orbit';
canvas.addEventListener('contextmenu', e=>e.preventDefault());
canvas.addEventListener('mousedown', (e)=>{
  drag=true; lastX=e.clientX; lastY=e.clientY;
  dragMode = (e.shiftKey || e.button===1 || e.button===2) ? 'pan' : 'orbit';
  canvas.classList.add('dragging');
});
window.addEventListener('mouseup', ()=>{ drag=false; canvas.classList.remove('dragging'); });
window.addEventListener('mousemove', (e)=>{
  if(!drag) return;
  const dx=(e.clientX-lastX), dy=(e.clientY-lastY);
  lastX=e.clientX; lastY=e.clientY;
  if(dragMode==='orbit'){
    cam.yaw   -= dx*0.010;
    cam.pitch -= dy*0.008;
    const lim = Math.PI/2 - 0.03;
    cam.pitch = Math.max(-lim, Math.min(lim, cam.pitch));
  }else{
    cam.panX += dx; cam.panY += dy;
  }
  render({nodes,beams,conditions}, results);
});
canvas.addEventListener('wheel', (e)=>{
  e.preventDefault();
  setZoom(cam.zoom * (e.deltaY>0 ? 0.9 : 1.1));
  render({nodes,beams,conditions}, results);
}, {passive:false});
zoomEl.addEventListener('change', ()=>{
  setZoom(parseFloat(zoomEl.value)||1);
  render({nodes,beams,conditions}, results);
});
document.getElementById('toggleBeams').addEventListener('click', (e)=>{
  showBeamGraphics = !showBeamGraphics;
  const btn = e.currentTarget;
  btn.setAttribute('aria-pressed', showBeamGraphics? 'true':'false');
  btn.textContent = showBeamGraphics ? 'Hide Beam Graphics' : 'Show Beam Graphics';
  render({nodes,beams,conditions}, results);
});
document.getElementById('toggleStress').addEventListener('click', (e)=>{
  if(!results){ setStatus('Solve first to compute stresses.', false); return; }
  showStressMap = !showStressMap;
  const btn = e.currentTarget;
  btn.setAttribute('aria-pressed', showStressMap? 'true':'false');
  btn.textContent = showStressMap ? 'Hide Stress Map' : 'Show Stress Map';
  if(!stressStats) stressStats = computeStressStats({nodes,beams,conditions}, results);
  render({nodes,beams,conditions}, results);
});
function setIsoView(){
  cam.yaw = 225*Math.PI/180;
  cam.pitch = -Math.atan(1/Math.SQRT2);
  setZoom(1); cam.panX=0; cam.panY=0;
  computeTarget({nodes,beams,conditions});
  computeFitScale({nodes,beams,conditions}, results);
  render({nodes,beams,conditions}, results);
}
canvas.addEventListener('dblclick', setIsoView);
window.addEventListener('resize', ()=>{
  computeFitScale({nodes,beams,conditions}, results);
  render({nodes,beams,conditions}, results);
});

/* =========================
   Wiring
   ========================= */
const specEl=document.getElementById('spec');

function updateLibrariesUI(libs){
  const mUL = document.getElementById('libMaterials');
  const xUL = document.getElementById('libXSections');
  if(!mUL || !xUL) return;
  mUL.innerHTML=''; xUL.innerHTML='';
  const fmtEng=v=>{
    if(!isFinite(v)) return '';
    if(v===0) return '0';
    const exp=Math.floor(Math.log10(Math.abs(v))); const exp3=Math.floor(exp/3)*3; const mant=v/Math.pow(10,exp3);
    const mantStr=(Math.abs(mant)>=100?mant.toFixed(0):Math.abs(mant)>=10?mant.toFixed(1):mant.toFixed(2)).replace(/\.?0+$/,'');
    return `${mantStr}e${exp3}`;
  };
  Object.entries(libs.materials||{}).forEach(([name,mat])=>{
    const li=document.createElement('li');
    const sy = (mat.sy!=null && isFinite(mat.sy)) ? ` Sy=${fmtEng(mat.sy)}` : '';
    li.textContent = `${name}: E=${fmtEng(mat.E)} nu=${(mat.nu).toFixed(2)}${sy}`;
    mUL.appendChild(li);
  });
  Object.entries(libs.xsections||{}).forEach(([name,xs])=>{
    const li=document.createElement('li');
    const dims = Object.entries(xs.dims||{}).map(([k,v])=>`${k}=${fmtEng(v)}`).join(' ');
    const up = xs.up?` up=(${xs.up.join(',')})`:'';
    li.textContent = `${name}: shape=${xs.shape} ${dims}${up}`;
    xUL.appendChild(li);
  });
}

function refreshFromSpec(){
  const {errors, model, libraries: libs, exagOverride: exo, nuGlobal: nug} = parseSpec(specEl.value);
  if(animationActive) stopAnimation();
  if(exo!=null) exagEl.value=exo;
  if(nug!=null) nuGlobal=nug;
  if(libs){ materialsLib = libs.materials||{}; xsectionsLib = libs.xsections||{}; updateLibrariesUI(libs); }

  errorsEl.textContent = errors.length ? errors.join('\n') : '';
  if(errors.length){
    setStatus('Parse errors. Fix spec to proceed.', false);
    nodes=[]; beams=[]; conditions={}; nodeMasses={}; results=null;
    lastAssembly=null; lastFrfResults=null;
  }else{
    nodes=model.nodes; beams=model.beams; conditions=model.conditions; nodeMasses=model.masses||{}; setStatus('Parsed OK.');
    lastAssembly=null; lastFrfResults=null;
  }

  // refresh modal beam id list if open
  populateBeamIdSelect(model.beams);

  computeTarget({nodes,beams,conditions});
  computeFitScale({nodes,beams,conditions}, results);
  updateResultsUI(results, {nodes,beams,conditions});
  // reset stress stats when spec changes
  stressStats = (results ? computeStressStats({nodes,beams,conditions}, results) : null);
  render({nodes,beams,conditions}, results);
  if(dynOverlay.style.display==='flex') populateDynamicsSelectors();
}
specEl.addEventListener('input', refreshFromSpec);

document.getElementById('btnSolve').addEventListener('click', ()=>{
  if(animationActive) stopAnimation();
  try{
    const parsed = parseSpec(specEl.value);
    const {errors, model} = parsed;
    if(errors.length){
      errorsEl.textContent=errors.join('\n');
      setStatus('Fix parsing errors to solve.', false);
      results=null;
      computeTarget(model);
      computeFitScale(model, results);
      updateResultsUI(null, model);
      render(model, null);
      return;
    }
    errorsEl.textContent='';
    nodeMasses = model.masses || {};
    showProgress('Solving static response…', 0);
    setStatus('Solving static response…');
    requestAnimationFrame(()=>{
      requestAnimationFrame(async ()=>{
        try{
          const out = await solve3D(model, (fraction, label)=> showProgress(label || 'Solving static response…', fraction));
          results = out;
          setStatus('Solved. Showing undeformed + deformed shapes.');
          stressStats = computeStressStats(model, results);
          computeTarget(model);
          computeFitScale(model, results);
          updateResultsUI(results, model);
          render(model, results);
          hideProgress(400);
        }catch(err){
          results=null;
          stressStats=null;
          errorsEl.textContent=String(err.message||err);
          setStatus('Solve failed.', false);
          computeTarget(model);
          computeFitScale(model, results);
          updateResultsUI(null, model);
          render(model, null);
          hideProgress(0);
        }
      });
    });
  }catch(err){
    results=null;
    stressStats=null;
    errorsEl.textContent=String(err.message||err);
    setStatus('Solve failed.', false);
    computeTarget({nodes,beams,conditions});
    computeFitScale({nodes,beams,conditions}, results);
    updateResultsUI(null, {nodes,beams,conditions});
    render({nodes,beams,conditions}, null);
    hideProgress(0);
  }
});

document.getElementById('btnSave').addEventListener('click', saveModelSpecToESSA);

document.getElementById('btnReset').addEventListener('click', ()=>{
  specEl.value = presetText('unittest');
  results=null; refreshFromSpec(); setStatus('Reset to preset.');
});

exagEl.addEventListener('change', ()=>{
  computeTarget({nodes,beams,conditions});
  computeFitScale({nodes,beams,conditions}, results);
  render({nodes,beams,conditions}, results);
});

/* =========================
   Presets (includes Compliant)
   ========================= */
function presetText(name){
  if(name==='cantilever'){
    return `# 3D Cantilever along X with tip load in Z
exag = 20
nu   = 0.30

nodes:
  1:  (0.0, 0, 0)
  2:  (0.1, 0, 0)
  3:  (0.2, 0, 0)
  4:  (0.3, 0, 0)
  5:  (0.4, 0, 0)
  6:  (0.5, 0, 0)
  7:  (0.6, 0, 0)
  8:  (0.7, 0, 0)
  9:  (0.8, 0, 0)
  10: (0.9, 0, 0)
  11: (1.0, 0, 0)

beams:
  1: 1-2  E=210e9  A=0.01  Iy=1e-4  Iz=1e-4  J=2e-4  up=(0,0,1)
  2: 2-3  E=210e9  A=0.01  Iy=1e-4  Iz=1e-4  J=2e-4  up=(0,0,1)
  3: 3-4  E=210e9  A=0.01  Iy=1e-4  Iz=1e-4  J=2e-4  up=(0,0,1)
  4: 4-5  E=210e9  A=0.01  Iy=1e-4  Iz=1e-4  J=2e-4  up=(0,0,1)
  5: 5-6  E=210e9  A=0.01  Iy=1e-4  Iz=1e-4  J=2e-4  up=(0,0,1)
  6: 6-7  E=210e9  A=0.01  Iy=1e-4  Iz=1e-4  J=2e-4  up=(0,0,1)
  7: 7-8  E=210e9  A=0.01  Iy=1e-4  Iz=1e-4  J=2e-4  up=(0,0,1)
  8: 8-9  E=210e9  A=0.01  Iy=1e-4  Iz=1e-4  J=2e-4  up=(0,0,1)
  9: 9-10  E=210e9  A=0.01  Iy=1e-4  Iz=1e-4  J=2e-4  up=(0,0,1)
  10: 10-11  E=210e9  A=0.01  Iy=1e-4  Iz=1e-4  J=2e-4  up=(0,0,1)

conditions:
  1: fixed
  11: force Fx=0 Fy=0 Fz=-1000 Mx=0 My=0 Mz=0
`;
  } else if(name==='portal'){
    return `# Portal frame in XZ plane, Z up, load at top
exag = 15
nu   = 0.30

nodes:
  1: (0, 0, 0)
  2: (0, 0, 2)
  3: (3, 0, 2)
  4: (3, 0, 0)

beams:
  1: 1-2  E=200e9 A=0.01 Iy=8e-5 Iz=8e-5 J=1.6e-4 up=(0,0,1)
  2: 2-3  E=200e9 A=0.01 Iy=8e-5 Iz=8e-5 J=1.6e-4 up=(0,0,1)
  3: 3-4  E=200e9 A=0.01 Iy=8e-5 Iz=8e-5 J=1.6e-4 up=(0,0,1)

conditions:
  1: fixed
  4: fixed
  3: force Fx=0 Fy=0 Fz=-2000 Mx=0 My=0 Mz=0
`;
  } else if(name==='space'){
    return `# Space frame corner load
exag = 12
nu   = 0.30

nodes:
  1: (0, 0, 0)
  2: (2, 0, 0)
  3: (2, 2, 0)
  4: (0, 2, 0)
  5: (0, 0, 2)
  6: (2, 0, 2)
  7: (2, 2, 2)
  8: (0, 2, 2)

beams:
  1: 1-2 E=210e9 A=0.01 Iy=6e-5 Iz=6e-5 J=1.2e-4 up=(0,0,1)
  2: 2-3 E=210e9 A=0.01 Iy=6e-5 Iz=6e-5 J=1.2e-4 up=(0,0,1)
  3: 3-4 E=210e9 A=0.01 Iy=6e-5 Iz=6e-5 J=1.2e-4 up=(0,0,1)
  4: 4-1 E=210e9 A=0.01 Iy=6e-5 Iz=6e-5 J=1.2e-4 up=(0,0,1)
  5: 5-6 E=210e9 A=0.01 Iy=6e-5 Iz=6e-5 J=1.2e-4 up=(0,0,1)
  6: 6-7 E=210e9 A=0.01 Iy=6e-5 Iz=6e-5 J=1.2e-4 up=(0,0,1)
  7: 7-8 E=210e9 A=0.01 Iy=6e-5 Iz=6e-5 J=1.2e-4 up=(0,0,1)
  8: 8-5 E=210e9 A=0.01 Iy=6e-5 Iz=6e-5 J=1.2e-4 up=(0,0,1)
  9: 1-5 E=210e9 A=0.01 Iy=6e-5 Iz=6e-5 J=1.2e-4 up=(0,1,0)
  10:2-6 E=210e9 A=0.01 Iy=6e-5 Iz=6e-5 J=1.2e-4 up=(0,1,0)
  11:3-7 E=210e9 A=0.01 Iy=6e-5 Iz=6e-5 J=1.2e-4 up=(0,1,0)
  12:4-8 E=210e9 A=0.01 Iy=6e-5 Iz=6e-5 J=1.2e-4 up=(0,1,0)

conditions:
  1: fixed
  2: fixed
  4: fixed
  8: free
  7: force Fx=500 Fy=300 Fz=-1000 Mx=0 My=0 Mz=0
`;
  } else if(name==='compliant'){
    return `# Compliant Mount: mid-node supported by springs (bushing to ground)
exag = 25
nu   = 0.30

nodes:
  1: (0, 0, 0)
  2: (2.0, 0, 0)
  3: (4.0, 0, 0)

beams:
  1: 1-2  E=210e9 A=0.01 Iy=8e-5 Iz=8e-5 J=1.6e-4 up=(0,0,1)
  2: 2-3  E=210e9 A=0.01 Iy=8e-5 Iz=8e-5 J=1.6e-4 up=(0,0,1)

conditions:
  1: fixed
  2: bushing_ground kx=2e6 ky=2e6 kz=4e6 krx=5e5 kry=5e5 krz=2e5
  3: force Fx=0 Fy=0 Fz=-1500 Mx=0 My=0 Mz=0
`;
  } else if(name==='springdemo'){
    return `# Axial spring example: rigid cap with four springs
exag = 30
nu   = 0.30

nodes:
  1: (0.0, 0.0, 0.0)
  2: (1.0, 1.0, 0.0)
  3: (1.0, -1.0, 0.0)
  4: (-1.0, 1.0, 0.0)
  5: (-1.0, -1.0, 0.0)
  6: (1.0, 1.0, -1.0)
  7: (1.0, -1.0, -1.0)
  8: (-1.0, 1.0, -1.0)
  9: (-1.0, -1.0, -1.0)

beams:
  1: 1-2 rigid
  2: 1-3 rigid
  3: 1-4 rigid
  4: 1-5 rigid
  5: 2-6 spring k=100000
  6: 3-7 spring k=100000
  7: 4-8 spring k=100000
  8: 5-9 spring k=100000

masses:
  1: mx=150 my=150 mz=150 ix=20 iy=20 iz=20 width=0.1 length=0.1 height=0.1
  2: mx=80 my=80 mz=80 ix=12 iy=12 iz=12 width=0.1 length=0.1 height=0.1
  3: mx=80 my=80 mz=80 ix=12 iy=12 iz=12 width=0.1 length=0.1 height=0.1
  4: mx=80 my=80 mz=80 ix=12 iy=12 iz=12 width=0.1 length=0.1 height=0.1
  5: mx=80 my=80 mz=80 ix=12 iy=12 iz=12 width=0.1 length=0.1 height=0.1
  6: mx=300 my=300 mz=300 ix=40 iy=40 iz=40 width=0.1 length=0.1 height=0.1
  7: mx=300 my=300 mz=300 ix=40 iy=40 iz=40 width=0.1 length=0.1 height=0.1
  8: mx=300 my=300 mz=300 ix=40 iy=40 iz=40 width=0.1 length=0.1 height=0.1
  9: mx=300 my=300 mz=300 ix=40 iy=40 iz=40 width=0.1 length=0.1 height=0.1

conditions:
  2: force Fx=0 Fy=0 Fz=-1000 Mx=0 My=0 Mz=0
  6: fixed
  7: fixed
  8: fixed
  9: fixed
`;
  }
  else if(name==='newspec'){
    return `# New-spec preset: libraries + cross-sections
exag = 18

materials:
  steel:  E=210e9 nu=0.30
  al6061: E=69e9  nu=0.33

xsections:
  col:       shape=rect b=0.08 h=0.16 up=(0,0,1)
  tube50x4:  shape=tube D=0.05 t=0.004 up=(0,0,1)

nodes:
  1: (0, 0, 0)
  2: (0, 0, 2)
  3: (3, 0, 2)
  4: (3, 0, 0)

beams:
  # Columns use rectangular section from library; beam uses tube from library
  1: 1-2  material:steel xsection:col
  2: 2-3  material:steel xsection:tube50x4
  3: 3-4  material:steel xsection:col
  # Example of inline shape (no xsection ref):
  # 4: 2-4  material:al6061 shape=ibeam Bf=0.10 H=0.20 tf=0.008 tw=0.006 up=(0,0,1)

conditions:
  1: fixed
  4: fixed
  2: force Fx=0 Fy=0 Fz=-1500 Mx=0 My=0 Mz=0
`;
  }
  else if(name==='unittest'){
    return `# New-spec preset: libraries + cross-sections
exag = 10

materials:
  steel:  E=210e9 nu=0.30

xsections:
  col: shape=rect b=0.1 h=0.1 up=(0,0,1)

nodes:
  1: (0.0, 0.0, 0.0)
  2: (0.0, 0.0, 1.0)
  3: (0.5, 0.0, 0.0)
  4: (0.5, 0.0, 1.0)
  5: (1.0, 0.0, 0.0)
  6: (1.0, 0.0, 1.0)

beams:
  1: 1-2  material:steel xsection:col
  2: 3-4  material:steel xsection:col
  3: 5-6  material:steel xsection:col

conditions:
  1: fixed
  2: force Fx=0 Fy=0 Fz=-100000 Mx=0 My=0 Mz=0
  3: fixed
  4: force Fx=0 Fy=1000 Fz=0 Mx=0 My=0 Mz=0
  5: fixed
  6: force Fx=1000 Fy=0 Fz=0 Mx=0 My=0 Mz=0
`;
  }
  return '';
}
document.getElementById('btnPreset').addEventListener('click', loadSelectedPresetOrFile);

/* =========================
   Cross-Section Modal Logic
   ========================= */
const overlay = document.getElementById('xsecOverlay');
const btnXSec = document.getElementById('btnXSec');
const btnClose = document.getElementById('xsecClose');
const matLib = document.getElementById('matLib');
const matE = document.getElementById('matE');
const matNu = document.getElementById('matNu');
const shapeSel = document.getElementById('shape');
const upVec = document.getElementById('upVec');

const outA = document.getElementById('outA');
const outIy = document.getElementById('outIy');
const outIz = document.getElementById('outIz');
const outJ = document.getElementById('outJ');
const outG = document.getElementById('outG');
const snippetEl = document.getElementById('snippet');
const snMode = document.getElementById('snMode');
const beamIdSelect = document.getElementById('beamIdSelect');
const snRigid = document.getElementById('snRigid');

const dimGroups = {
  rect: document.querySelectorAll('.dim-rect'),
  rectTube: document.querySelectorAll('.dim-rectTube'),
  circ: document.querySelectorAll('.dim-circ'),
  tube: document.querySelectorAll('.dim-tube'),
  ibeam: document.querySelectorAll('.dim-ibeam'),
};
function showDims(which){
  for(const k in dimGroups){
    dimGroups[k].forEach(el=> el.style.display = (k===which)?'block':'none');
  }
}
showDims('rect');

function eng(v){
  if(!isFinite(v)) return '';
  if(v===0) return '0';
  const sign = v<0?'-':'';
  v=Math.abs(v);
  const exp = Math.floor(Math.log10(v));
  const exp3 = Math.floor(exp/3)*3;
  const mant = v/Math.pow(10,exp3);
  const mantStr = (mant>=100? mant.toFixed(0) : mant>=10? mant.toFixed(1) : mant.toFixed(2)).replace(/\.?0+$/,'');
  return `${sign}${mantStr}e${exp3}`;
}
function parseVec3(str){
  const m=str.split(',').map(s=>parseFloat(s.trim()));
  if(m.length!==3 || m.some(x=>!isFinite(x))) return [0,0,1];
  return m;
}
function updateMatFields(){
  if(matLib.value==='steel'){ matE.value='210e9'; matNu.value='0.30'; }
  else if(matLib.value==='al'){ matE.value='69e9'; matNu.value='0.33'; }
  else if(matLib.value==='ti'){ matE.value='114e9'; matNu.value='0.34'; }
  computeProps();
}
matLib.addEventListener('change', updateMatFields);

function evalNum(str){
  try{
    if(!/^[\s+-]?\d*\.?\d+(e[+-]?\d+)?\s*$/i.test(String(str))) return NaN;
    return Number(str);
  }catch{ return NaN; }
}

function computeProps(){
  const E = Number(evalNum(matE.value));
  const nu = parseFloat(matNu.value);
  const G = E/(2*(1+nu));
  let A=NaN, Iy=NaN, Iz=NaN, J=NaN;
  let dimsForSnip={};

  const sh = shapeSel.value;

  if(sh==='rect'){
    const b = parseFloat(document.getElementById('rect_b').value);
    const h = parseFloat(document.getElementById('rect_h').value);
    A = b*h;
    Iy = b*h*h*h/12;
    Iz = h*b*b*b/12;
    let B=b, H=h;
    if(H>B){ const t=B; B=H; H=t; }
    const r = H/B;
    J = B*H*H*H*(1/3 - 0.21*r*(1 - 0.2*r*r*r*r));
    dimsForSnip={b,h};
  }else if(sh==='rectTube'){
    const B = parseFloat(document.getElementById('rt_B').value);
    const H = parseFloat(document.getElementById('rt_H').value);
    const t = parseFloat(document.getElementById('rt_t').value);
    if(B<=2*t || H<=2*t){ A=Iy=Iz=J=NaN; }
    else{
      const Bi=B-2*t, Hi=H-2*t;
      A = B*H - Bi*Hi;
      Iy = (B*H**3 - Bi*Hi**3)/12;
      Iz = (H*B**3 - Hi*Bi**3)/12;
      const Am = (B - t)*(H - t);
      const denom = 2*(B+H-2*t)/t;
      J = 4*Am*Am/denom;
    }
    dimsForSnip={B,H,t};
  }else if(sh==='circ'){
    const d = parseFloat(document.getElementById('c_d').value);
    A = Math.PI*d*d/4;
    Iy = Iz = Math.PI*Math.pow(d,4)/64;
    J = Math.PI*Math.pow(d,4)/32;
    dimsForSnip={d};
  }else if(sh==='tube'){
    const D = parseFloat(document.getElementById('t_D').value);
    const t = parseFloat(document.getElementById('t_t').value);
    const d = D - 2*t;
    if(d<=0){ A=Iy=Iz=J=NaN; }
    else{
      A = Math.PI*(D*D - d*d)/4;
      Iy = Iz = Math.PI*(Math.pow(D,4)-Math.pow(d,4))/64;
      J = Math.PI*(Math.pow(D,4)-Math.pow(d,4))/32;
    }
    dimsForSnip={D,t};
  }else if(sh==='ibeam'){
    const Bf = parseFloat(document.getElementById('ib_Bf').value);
    const H  = parseFloat(document.getElementById('ib_H').value);
    const tf = parseFloat(document.getElementById('ib_tf').value);
    const tw = parseFloat(document.getElementById('ib_tw').value);
    const hw = H - 2*tf;
    if(hw<=0){ A=Iy=Iz=J=NaN; }
    else{
      A = 2*(Bf*tf) + (tw*hw);
      const Iy_fl = Bf*tf**3/12;
      const Iy_web = tw*hw**3/12;
      Iy = 2*Iy_fl + Iy_web;
      const Iz_fl_c = tf*Bf**3/12;
      const dy = (H/2 - tf/2);
      const Iz_fl = Iz_fl_c + (Bf*tf)*dy*dy;
      const Iz_web = hw*tw**3/12;
      Iz = 2*Iz_fl + Iz_web;
      J = 2*(Bf*tf**3)/3 + (hw*tw**3)/3;
    }
    dimsForSnip={Bf,H,tf,tw};
  }

  outA.value  = eng(A);
  outIy.value = eng(Iy);
  outIz.value = eng(Iz);
  outJ.value  = eng(J);
  outG.value  = eng(G);

  const up = parseVec3(upVec.value);
  let snip='';
  if((snMode?.value||'props')==='shape'){
    const dimsTxt = Object.entries(dimsForSnip).map(([k,v])=>`${k}=${eng(v)}`).join(' ');
    snip = `shape=${sh} ${dimsTxt} up=(${up[0]},${up[1]},${up[2]})`;
  }else{
    snip = `E=${eng(E)} A=${eng(A)} Iy=${eng(Iy)} Iz=${eng(Iz)} J=${eng(J)} G=${eng(G)} up=(${up[0]},${up[1]},${up[2]})`;
  }
  if(document.getElementById('snRigid').checked) snip += ' rigid';
  snippetEl.textContent = snip;
}

shapeSel.addEventListener('change', ()=>{ showDims(shapeSel.value); computeProps(); });
['rect_b','rect_h','rt_B','rt_H','rt_t','c_d','t_D','t_t','ib_Bf','ib_H','ib_tf','ib_tw','upVec','matE','matNu','snRigid']
  .forEach(id=>{ const el=document.getElementById(id); if(el) el.addEventListener('input', computeProps); });
snMode.addEventListener('change', computeProps);

function openModal(){
  overlay.style.display='flex';
  overlay.setAttribute('aria-hidden','false');
  populateBeamIdSelect(beams);
  computeProps();
}
function closeModal(){
  overlay.style.display='none';
  overlay.setAttribute('aria-hidden','true');
}
btnXSec.addEventListener('click', openModal);
btnClose.addEventListener('click', closeModal);
overlay.addEventListener('click', (e)=>{ if(e.target===overlay) closeModal(); });
document.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && overlay.style.display==='flex') closeModal(); });

// Libraries modal wiring
const libsOverlay = document.getElementById('libsOverlay');
const btnLibs = document.getElementById('btnLibs');
const libsClose = document.getElementById('libsClose');
function openLibs(){ libsOverlay.style.display='flex'; libsOverlay.setAttribute('aria-hidden','false'); }
function closeLibs(){ libsOverlay.style.display='none'; libsOverlay.setAttribute('aria-hidden','true'); }
btnLibs.addEventListener('click', openLibs);
libsClose.addEventListener('click', closeLibs);
libsOverlay.addEventListener('click', (e)=>{ if(e.target===libsOverlay) closeLibs(); });
document.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && libsOverlay.style.display==='flex') closeLibs(); });

document.getElementById('btnDynamics').addEventListener('click', ()=>{
  document.querySelectorAll('canvas.frfCanvas').forEach(c=>{
    if(c!==dynMagCanvas && c!==dynPhaseCanvas) c.remove();
  });
  dynOverlay.style.display='flex';
  dynOverlay.setAttribute('aria-hidden','false');
  populateDynamicsSelectors();
  if(!dynFreqStartEl.value) dynFreqStartEl.value='1';
  if(!dynFreqEndEl.value) dynFreqEndEl.value='100';
  if(!dynFreqPointsEl.value) dynFreqPointsEl.value='200';
  dynErrorsEl.textContent='';
    if(lastFrfResults){
      renderDynamicsResults(lastFrfResults);
    }else{
      renderDynamicsResults(null);
    }
});
document.getElementById('dynCompute').addEventListener('click', handleDynamicsCompute);
document.getElementById('dynClose').addEventListener('click', ()=>{
  dynOverlay.style.display='none';
  dynOverlay.setAttribute('aria-hidden','true');
});
dynOverlay.addEventListener('click', (e)=>{ if(e.target===dynOverlay) { dynOverlay.style.display='none'; dynOverlay.setAttribute('aria-hidden','true'); }});
document.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && dynOverlay.style.display==='flex'){ dynOverlay.style.display='none'; dynOverlay.setAttribute('aria-hidden','true'); }});
dynNormalizeEl?.addEventListener('change', ()=>{
  if(lastFrfResults){
    renderDynamicsResults(lastFrfResults);
  }
});
btnAnimate.addEventListener('click', toggleAnimation);

function populateBeamIdSelect(beamArr){
  beamIdSelect.innerHTML = '';
  (beamArr||[]).forEach(b=>{
    const opt=document.createElement('option');
    opt.value=String(b.id); opt.textContent = `Beam ${b.id}: ${b.nodeA}-${b.nodeB}`;
    beamIdSelect.appendChild(opt);
  });
}

document.getElementById('btnCopy').addEventListener('click', async ()=>{
  await navigator.clipboard.writeText(snippetEl.textContent);
});

document.getElementById('btnInsert').addEventListener('click', ()=>{
  const snip = snippetEl.textContent;
  const ta = specEl;
  const start = ta.selectionStart, end = ta.selectionEnd;
  const v = ta.value;
  ta.value = v.slice(0,start) + snip + v.slice(end);
  ta.focus();
  ta.selectionStart = ta.selectionEnd = start + snip.length;
  refreshFromSpec();
});

document.getElementById('btnApply').addEventListener('click', ()=>{
  if((snMode?.value||'props')==='shape'){
    alert('Apply works with Properties mode. Use Insert or Copy for shape snippets.');
    return;
  }
  const id = beamIdSelect.value;
  if(!id) return;
  const snip = snippetEl.textContent;

  const lines = specEl.value.split(/\r?\n/);
  let inBeams=false;
  for(let i=0;i<lines.length;i++){
    const L=lines[i];
    if(/^\s*beams\s*:\s*$/i.test(L)){ inBeams=true; continue; }
    if(inBeams){
      if(/^\s*(nodes|conditions)\s*:\s*$/i.test(L)) break;
      const m=L.match(/^\s*(\d+)\s*:\s*(\d+)\s*-\s*(\d+)\s*(.*)$/);
      if(m && m[1]===id){
        const prefix = `${m[1]}: ${m[2]}-${m[3]}  `;
        let rest = m[4]||'';
        const upOld = (rest.match(/up=\([^)]+\)/i)||[])[0] || '';
        const upNew = (snip.match(/up=\([^)]+\)/i)||[])[0] || '';
        const keepUp = upNew || upOld;

        rest = rest.replace(/\b(E|A|Iy|Iz|J|G)\s*=\s*([^\s)]+)\s*/gi,'')
                   .replace(/up=\([^)]+\)/i,'')
                   .trim();

        lines[i] = '  ' + prefix + snip.replace(/\s*up=\([^)]+\)/i,'') + (keepUp?(' '+keepUp):'') + (rest?(' '+rest):'');
        break;
      }
    }
  }
  specEl.value = lines.join('\n');
  refreshFromSpec();
});

/* =========================
   Init
   ========================= */
document.getElementById('btnXSec').title = 'Compute E, A, Iy, Iz, J (and G) from a cross-section';
document.getElementById('btnXSec').ariaHasPopup = 'dialog';

specEl.value = presetText('unittest');
refreshFromSpec();
setZoom(1);
updateMatFields(); // initialize material -> E, ν set + compute

/* =========================
   File access: Save to ~/Documents/ESSA + load files into Presets
   ========================= */
const TEST_FILENAME = 'test.essa';   // <- change if you want a different test file name

// --- tiny IndexedDB wrapper so we can remember the folder handle across reloads ---
const DB_NAME='essa-store', STORE='fs';
function idbOpen(){
  return new Promise((res, rej)=>{
    const r = indexedDB.open(DB_NAME, 1);
    r.onupgradeneeded = () => r.result.createObjectStore(STORE);
    r.onsuccess = () => res(r.result);
    r.onerror = () => rej(r.error);
  });
}
async function idbSet(key, val){
  const db = await idbOpen();
  return new Promise((res, rej)=>{
    const tx = db.transaction(STORE, 'readwrite');
    tx.objectStore(STORE).put(val, key);
    tx.oncomplete = () => res();
    tx.onerror = () => rej(tx.error);
  });
}
async function idbGet(key){
  const db = await idbOpen();
  return new Promise((res, rej)=>{
    const tx = db.transaction(STORE, 'readonly');
    const req = tx.objectStore(STORE).get(key);
    req.onsuccess = () => res(req.result);
    req.onerror = () => rej(req.error);
  });
}

// --- ask (once) for the ESSA directory; remember it in IndexedDB ---
async function getESSADirHandle() {
  try{
    // 1) Try a previously approved handle
    let dir = await idbGet('essaDir');
    if (dir && dir.requestPermission) {
      const p = await dir.queryPermission?.({mode:'readwrite'});
      if (p === 'granted') return dir;
      const p2 = await dir.requestPermission({mode:'readwrite'});
      if (p2 === 'granted') return dir;
    }

    // 2) If browser doesn’t support the API, bail to fallback
    if (!window.showDirectoryPicker) return null;

    // 3) Ask user to pick ~/Documents (or wherever) then ensure an "ESSA" subfolder exists
    const picked = await window.showDirectoryPicker({ id: 'ESSA', startIn: 'documents' });
    let target = picked;
    if (picked.name !== 'ESSA') {
      try { target = await picked.getDirectoryHandle('ESSA', { create: true }); }
      catch { /* ignore; user may not let us create here */ }
    }

    // Confirm permission
    const perm = await target.requestPermission?.({mode:'readwrite'});
    if (perm !== 'granted') return null;

    await idbSet('essaDir', target);
    return target;
  }catch(err){
    console.warn('getESSADirHandle:', err);
    return null;
  }
}

// --- Save the spec text as test.essa into that folder (or download fallback) ---
async function saveModelSpecToESSA() {
  const text = document.getElementById('spec').value;
  const dir = await getESSADirHandle();

  // Fallback if FS Access API unavailable or permission denied
  if (!dir) {
    const blob = new Blob([text], {type:'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = TEST_FILENAME; a.click();
    URL.revokeObjectURL(url);
    setStatus('Saved via download (no filesystem permission).');
    return;
  }

  try{
    const fh = await dir.getFileHandle(TEST_FILENAME, { create: true });
    const ws = await fh.createWritable();
    await ws.write(text);
    await ws.close();
    setStatus(`Saved to ${dir.name}/${TEST_FILENAME}`);
    await refreshUserFilesPreset(dir);   // refresh the dropdown so test.essa appears
  }catch(err){
    console.error(err);
    setStatus('Save failed.', false);
  }
}

// --- Build "My Files (ESSA)" into the Presets dropdown from valid files ---
let __essaFileMap = {}; // name -> { handle }
async function refreshUserFilesPreset(dir) {
  try{
    dir = dir || await idbGet('essaDir');
    if (!dir) return;

    // Ensure permission is still valid
    const q = await dir.queryPermission?.({mode:'readwrite'});
    if (q !== 'granted') {
      const r = await dir.requestPermission?.({mode:'readwrite'});
      if (r !== 'granted') return;
    }

    const sel = document.getElementById('preset');
    // Remove old optgroup if present
    const old = document.getElementById('userFilesGroup');
    if (old) old.remove();

    const og = document.createElement('optgroup');
    og.id = 'userFilesGroup';
    og.label = 'My Files (ESSA)';
    __essaFileMap = {};

    for await (const [name, handle] of dir.entries()) {
      if (handle.kind !== 'file') continue;
      // Accept typical text-like specs
      if (!/\.(essa|txt|spec|yaml|yml|json|md)$/i.test(name)) continue;

      // Validate by parsing; only add if parseSpec() has no errors
      const file = await handle.getFile();
      const text = await file.text();
      const { errors } = parseSpec(text);
      if (errors.length) continue;

      __essaFileMap[name] = { handle };
      const opt = document.createElement('option');
      opt.value = `file:${name}`;
      opt.textContent = `File: ${name}`;
      og.appendChild(opt);
    }

    // Only append if we found any files
    if (og.children.length) sel.appendChild(og);
  }catch(err){
    console.warn('refreshUserFilesPreset:', err);
  }
}

// Load selected preset OR file from ESSA group
async function loadSelectedPresetOrFile() {
  const sel = document.getElementById('preset');
  const val = sel.value;

  if (val.startsWith('file:')) {
    const name = val.slice(5);
    const entry = __essaFileMap[name];
    if (!entry) { await refreshUserFilesPreset(); }

    try{
      const file = await entry.handle.getFile();
      const text = await file.text();
      specEl.value = text;
      results = null;
      refreshFromSpec();
      setStatus(`Loaded: ${name}`);
    }catch(err){
      console.error(err);
      setStatus('Could not open the selected file.', false);
    }
  } else {
    specEl.value = presetText(val);
    results = null;
    refreshFromSpec();
  }
}

// Kick off a background attempt to populate the ESSA files into the dropdown on load
refreshUserFilesPreset().catch(()=>{});

/* ========= File access helpers (ensure ~/Documents/ESSA) ========= */
async function getOrCreateESSADir() {
  try {
    // Reuse cached handle if possible
    let dir = await idbGet('essaDir');
    if (dir && dir.queryPermission) {
      const p = await dir.queryPermission?.({mode:'readwrite'});
      if (p === 'granted') return dir;
      const p2 = await dir.requestPermission?.({mode:'readwrite'});
      if (p2 === 'granted') return dir;
    }

    if (!window.showDirectoryPicker) return null;

    // Ask for Documents, then ensure/create ESSA inside it
    const documents = await window.showDirectoryPicker({ id: 'documents', startIn: 'documents' });
    let essa = documents;
    if (documents.name !== 'ESSA') {
      essa = await documents.getDirectoryHandle('ESSA', { create: true });
    }

    const perm = await essa.requestPermission?.({mode:'readwrite'});
    if (perm !== 'granted') return null;

    await idbSet('essaDir', essa);
    return essa;
  } catch (err) {
    console.warn('getOrCreateESSADir:', err);
    return null;
  }
}

/* ========= Filename sanitation ========= */
const WINDOWS_RESERVED = new Set([
  'CON','PRN','AUX','NUL','COM1','COM2','COM3','COM4','COM5','COM6','COM7','COM8','COM9',
  'LPT1','LPT2','LPT3','LPT4','LPT5','LPT6','LPT7','LPT8','LPT9'
]);

function sanitizeFileName(name) {
  if (!name) return '';
  // Trim and strip invalid characters (Windows + common bad)
  let s = name.trim()
    .replace(/[<>:"/\\|?*\x00-\x1F]/g, '')  // control & forbidden
    .replace(/\s+/g, ' ')                    // collapse spaces
    .replace(/\.+$/g, '');                   // no trailing dots
  if (!s) return '';

  // Enforce .essa extension
  if (!/\.(essa)$/i.test(s)) s = s + '.essa';

  // Block reserved names (without extension)
  const base = s.replace(/\.[^.]+$/,'');
  if (WINDOWS_RESERVED.has(base.toUpperCase())) return '';

  // Reasonable max length
  if (s.length > 120) s = s.slice(0, 120);

  return s;
}

/* ========= Save modal open/close ========= */
const saveOverlay  = document.getElementById('saveOverlay');
const saveCloseBtn = document.getElementById('saveClose');
const saveCancel   = document.getElementById('saveCancel');
const saveConfirm  = document.getElementById('saveConfirm');
const saveNameIn   = document.getElementById('saveFileName');
const saveErrors   = document.getElementById('saveErrors');

function openSaveModal(defaultName='model.essa') {
  saveErrors.textContent = '';
  saveNameIn.value = defaultName;
  saveOverlay.style.display = 'flex';
  saveOverlay.setAttribute('aria-hidden','false');
  setTimeout(()=> saveNameIn.focus(), 0);
}
function closeSaveModal() {
  saveOverlay.style.display = 'none';
  saveOverlay.setAttribute('aria-hidden','true');
}
saveCloseBtn.addEventListener('click', closeSaveModal);
saveCancel.addEventListener('click', closeSaveModal);
saveOverlay.addEventListener('click', (e)=>{ if(e.target===saveOverlay) closeSaveModal(); });
document.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && saveOverlay.style.display==='flex') closeSaveModal(); });

/* ========= Main button handler ========= */
document.getElementById('btnSave').addEventListener('click', async () => {
  // Make sure we can reach/create ~/Documents/ESSA
  const dir = await getOrCreateESSADir();
  if (!dir) {
    setStatus('Cannot access ~/Documents. Using download fallback.', false);
    // Simple fallback: download current spec with a prompt() file name
    const proposed = 'model.essa';
    const raw = prompt('File name to download as:', proposed);
    if (raw == null) return;
    const cleaned = sanitizeFileName(raw);
    if (!cleaned) { alert('Invalid file name.'); return; }
    const blob = new Blob([specEl.value], {type:'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = cleaned; a.click();
    URL.revokeObjectURL(url);
    return;
  }

  // Show the in-app Save As modal
  openSaveModal('model.essa');

  // When user confirms, perform the save
  async function doSave() {
    saveErrors.textContent = '';
    let cleaned = sanitizeFileName(saveNameIn.value);
    if (!cleaned) {
      saveErrors.textContent = 'Please enter a valid file name (no reserved names or illegal characters).';
      return;
    }

    try {
      // Check if file exists to confirm overwrite
      let exists = false;
      try {
        await dir.getFileHandle(cleaned, { create: false });
        exists = true;
      } catch {}

      if (exists && !confirm(`"${cleaned}" already exists. Overwrite?`)) return;

      const fh = await dir.getFileHandle(cleaned, { create: true });
      const ws = await fh.createWritable();
      await ws.write(specEl.value);
      await ws.close();

      setStatus(`Saved to ${dir.name}/${cleaned}`);
      closeSaveModal();
      await refreshUserFilesPreset(dir); // so it appears under "My Files (ESSA)"
    } catch (err) {
      console.error(err);
      saveErrors.textContent = 'Save failed. Check permissions or try a different name.';
      setStatus('Save failed.', false);
    }
  }

  // Bind confirm click & Enter key (one-shot)
  const onClick = () => { saveConfirm.removeEventListener('click', onClick); saveNameIn.removeEventListener('keydown', onKey); doSave(); };
  const onKey = (e) => { if (e.key === 'Enter') { saveConfirm.removeEventListener('click', onClick); saveNameIn.removeEventListener('keydown', onKey); doSave(); } };

  saveConfirm.addEventListener('click', onClick);
  saveNameIn.addEventListener('keydown', onKey);
});

// --- View shortcuts: aim the camera so a given axis points at the camera ---
function setViewByNormal(nx, ny, nz){
  // normalize
  const L = Math.hypot(nx, ny, nz) || 1;
  nx /= L; ny /= L; nz /= L;

  // Convert desired forward vector f = (nx,ny,nz) to yaw/pitch used by cameraMatrix()
  // cameraMatrix uses: f = [cos(pitch)*cos(yaw), cos(pitch)*sin(yaw), sin(pitch)]
  cam.yaw   = Math.atan2(ny, nx);
  let pitch = Math.asin(nz);

  // Respect the same pitch limit the drag code uses (avoid the singularity)
  const lim = Math.PI/2 - 0.03;
  cam.pitch = Math.max(-lim, Math.min(lim, pitch));

  // Reset pan/zoom and re-fit
  cam.panX = 0; cam.panY = 0;
  setZoom(1);
  computeTarget({nodes,beams,conditions});
  computeFitScale({nodes,beams,conditions}, results);
  render({nodes,beams,conditions}, results);
}

// Wire the three buttons
document.getElementById('viewFront').addEventListener('click', ()=> {
  // Front: look along +Y (normal of the XZ “front” plane points at camera)
  setViewByNormal(-1, 0, 0);
});
document.getElementById('viewSide').addEventListener('click', ()=> {
  // Side: look along +X (normal of the YZ plane points at camera)
  setViewByNormal(0, -1, 0);
});
document.getElementById('viewTop').addEventListener('click', ()=> {
  // Top: look along +Z (normal of the XY plane points at camera)
  setViewByNormal(0, 0, -1);
});
document.getElementById('viewIso').addEventListener('click', setIsoView);


</script>
</body>
</html>
